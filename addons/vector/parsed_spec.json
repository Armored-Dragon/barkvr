{
  "endpoints": [
	{
	  "endpoint": "/.well-known/matrix/client",
	  "Discovery Information": [
		{
		  "name": "m.homeserver",
		  "type": "Homeserver Information",
		  "desc": "Required: Used by clients to discover homeserver information."
		},
		{
		  "name": "m.identity_server",
		  "type": "Identity Server Information",
		  "desc": "Used by clients to discover identity server information."
		}
	  ],
	  "Homeserver Information": [
		{
		  "name": "base_url",
		  "type": "string",
		  "desc": "Required: The base URL for the homeserver for client-server connections."
		}
	  ],
	  "Identity Server Information": [
		{
		  "name": "base_url",
		  "type": "string",
		  "desc": "Required: The base URL for the identity server for client-server connections."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/versions"
	},
	{
	  "endpoint": "/.well-known/matrix/support",
	  "Contact": [
		{
		  "name": "email_address",
		  "type": "string",
		  "desc": "An email address to reach the administrator.\n\nAt least one of matrix_id or email_address is required."
		},
		{
		  "name": "matrix_id",
		  "type": "string",
		  "desc": "A Matrix User ID representing the administrator.\n\nIt could be an account registered on a different homeserver so the administrator can be contacted when the homeserver is down.\n\nAt least one of matrix_id or email_address is required."
		},
		{
		  "name": "role",
		  "type": "string",
		  "desc": "Required:\n\nAn informal description of what the contact methods are used for.\n\nm.role.admin is a catch-all role for any queries and m.role.security is intended for sensitive requests.\n\nUnspecified roles are permitted through the use of Namespaced Identifiers.\n\nOne of: [m.role.admin, m.role.security]."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/register/m.login.registration_token/validity",
	  "query parameters": [
		{
		  "name": "token",
		  "type": "string",
		  "desc": "Required: The token to check validity of."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/login",
	  "LoginFlow": [
		{
		  "name": "get_login_token",
		  "type": "boolean",
		  "desc": "If type is m.login.token, an optional field to indicate to the unauthenticated client that the homeserver supports the POST /login/get_token endpoint. Note that supporting the endpoint does not necessarily indicate that the user attempting to log in will be able to generate such a token.\n\nAdded in v1.7"
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The login type. This is supplied as the type when logging in."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/login",
	  "User identifier": [
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of identification. See Identifier types for supported values and additional property descriptions."
		}
	  ],
	  "Discovery Information": [
		{
		  "name": "m.homeserver",
		  "type": "Homeserver Information",
		  "desc": "Required: Used by clients to discover homeserver information."
		},
		{
		  "name": "m.identity_server",
		  "type": "Identity Server Information",
		  "desc": "Used by clients to discover identity server information."
		}
	  ],
	  "Homeserver Information": [
		{
		  "name": "base_url",
		  "type": "string",
		  "desc": "Required: The base URL for the homeserver for client-server connections."
		}
	  ],
	  "Identity Server Information": [
		{
		  "name": "base_url",
		  "type": "string",
		  "desc": "Required: The base URL for the identity server for client-server connections."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/login/get_token",
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/refresh",
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/logout"
	},
	{
	  "endpoint": "/_matrix/client/v3/logout/all"
	},
	{
	  "endpoint": "/_matrix/client/v3/account/deactivate",
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/password",
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/password/email/requestToken",
	  "RequestTokenResponse": [
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session ID. Session IDs are opaque strings that must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
		},
		{
		  "name": "submit_url",
		  "type": "string",
		  "desc": "An optional field containing a URL where the client must submit the validation token to, with identical parameters to the Identity Service API’s POST /validate/email/submitToken endpoint (without the requirement for an access token). The homeserver must send this token to the user (if applicable), who should then be prompted to provide it to the client.\n\nIf this field is not present, the client can assume that verification will happen without the client’s involvement provided the homeserver advertises this specification version in the /versions response (ie: r0.5.0)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/password/msisdn/requestToken",
	  "RequestTokenResponse": [
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session ID. Session IDs are opaque strings that must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
		},
		{
		  "name": "submit_url",
		  "type": "string",
		  "desc": "An optional field containing a URL where the client must submit the validation token to, with identical parameters to the Identity Service API’s POST /validate/email/submitToken endpoint (without the requirement for an access token). The homeserver must send this token to the user (if applicable), who should then be prompted to provide it to the client.\n\nIf this field is not present, the client can assume that verification will happen without the client’s involvement provided the homeserver advertises this specification version in the /versions response (ie: r0.5.0)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/register",
	  "query parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "The kind of account to register. Defaults to user.\n\nOne of: [guest, user]."
		}
	  ],
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/register/available",
	  "query parameters": [
		{
		  "name": "username",
		  "type": "string",
		  "desc": "Required: The username to check the availability of."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/register/email/requestToken",
	  "RequestTokenResponse": [
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session ID. Session IDs are opaque strings that must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
		},
		{
		  "name": "submit_url",
		  "type": "string",
		  "desc": "An optional field containing a URL where the client must submit the validation token to, with identical parameters to the Identity Service API’s POST /validate/email/submitToken endpoint (without the requirement for an access token). The homeserver must send this token to the user (if applicable), who should then be prompted to provide it to the client.\n\nIf this field is not present, the client can assume that verification will happen without the client’s involvement provided the homeserver advertises this specification version in the /versions response (ie: r0.5.0)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/register/msisdn/requestToken",
	  "RequestTokenResponse": [
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session ID. Session IDs are opaque strings that must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
		},
		{
		  "name": "submit_url",
		  "type": "string",
		  "desc": "An optional field containing a URL where the client must submit the validation token to, with identical parameters to the Identity Service API’s POST /validate/email/submitToken endpoint (without the requirement for an access token). The homeserver must send this token to the user (if applicable), who should then be prompted to provide it to the client.\n\nIf this field is not present, the client can assume that verification will happen without the client’s involvement provided the homeserver advertises this specification version in the /versions response (ie: r0.5.0)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid",
	  "Third-party identifier": [
		{
		  "name": "added_at",
		  "type": "integer",
		  "desc": "Required: The timestamp, in milliseconds, when the homeserver associated the third-party identifier with the user."
		},
		{
		  "name": "address",
		  "type": "string",
		  "desc": "Required: The third-party identifier address."
		},
		{
		  "name": "medium",
		  "type": "string",
		  "desc": "Required: The medium of the third-party identifier.\n\nOne of: [email, msisdn]."
		},
		{
		  "name": "validated_at",
		  "type": "integer",
		  "desc": "Required: The timestamp, in milliseconds, when the identifier was validated by the identity server."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid",
	  "ThreePidCredentials": [
		{
		  "name": "client_secret",
		  "type": "string",
		  "desc": "Required: The client secret used in the session with the identity server."
		},
		{
		  "name": "id_access_token",
		  "type": "string",
		  "desc": "Required: An access token previously registered with the identity server. Servers can treat this as optional to distinguish between r0.5-compatible clients and this specification version."
		},
		{
		  "name": "id_server",
		  "type": "string",
		  "desc": "Required: The identity server to use."
		},
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session identifier given by the identity server."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid/add",
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid/bind",
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid/delete"
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid/email/requestToken",
	  "RequestTokenResponse": [
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session ID. Session IDs are opaque strings that must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
		},
		{
		  "name": "submit_url",
		  "type": "string",
		  "desc": "An optional field containing a URL where the client must submit the validation token to, with identical parameters to the Identity Service API’s POST /validate/email/submitToken endpoint (without the requirement for an access token). The homeserver must send this token to the user (if applicable), who should then be prompted to provide it to the client.\n\nIf this field is not present, the client can assume that verification will happen without the client’s involvement provided the homeserver advertises this specification version in the /versions response (ie: r0.5.0)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid/msisdn/requestToken",
	  "RequestTokenResponse": [
		{
		  "name": "sid",
		  "type": "string",
		  "desc": "Required: The session ID. Session IDs are opaque strings that must consist entirely of the characters [0-9a-zA-Z.=_-]. Their length must not exceed 255 characters and they must not be empty."
		},
		{
		  "name": "submit_url",
		  "type": "string",
		  "desc": "An optional field containing a URL where the client must submit the validation token to, with identical parameters to the Identity Service API’s POST /validate/email/submitToken endpoint (without the requirement for an access token). The homeserver must send this token to the user (if applicable), who should then be prompted to provide it to the client.\n\nIf this field is not present, the client can assume that verification will happen without the client’s involvement provided the homeserver advertises this specification version in the /versions response (ie: r0.5.0)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/account/3pid/unbind"
	},
	{
	  "endpoint": "/_matrix/client/v3/account/whoami",
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/capabilities",
	  "Capabilities": [
		{
		  "name": "m.change_password",
		  "type": "ChangePasswordCapability",
		  "desc": "Capability to indicate if the user can change their password."
		},
		{
		  "name": "m.room_versions",
		  "type": "RoomVersionsCapability",
		  "desc": "The room versions the server supports."
		}
	  ],
	  "ChangePasswordCapability": [
		{
		  "name": "enabled",
		  "type": "boolean",
		  "desc": "Required: True if the user can change their password, false otherwise."
		}
	  ],
	  "RoomVersionsCapability": [
		{
		  "name": "available",
		  "type": "{string: string}",
		  "desc": "Required: A detailed description of the room versions the server supports."
		},
		{
		  "name": "default",
		  "type": "string",
		  "desc": "Required: The default room version the server is using for new rooms."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/filter",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The id of the user uploading the filter. The access token must be authorized to make requests for this user id."
		}
	  ],
	  "Filter": [
		{
		  "name": "account_data",
		  "type": "EventFilter",
		  "desc": "The user account data that isn’t associated with rooms to include."
		},
		{
		  "name": "event_fields",
		  "type": "[string]",
		  "desc": "List of event fields to include. If this list is absent then all fields are included. The entries are dot-separated paths for each property to include. So [‘content.body’] will include the ‘body’ field of the ‘content’ object. A server may include more fields than were requested."
		},
		{
		  "name": "event_format",
		  "type": "string",
		  "desc": "The format to use for events. ‘client’ will return the events in a format suitable for clients. ‘federation’ will return the raw event as received over federation. The default is ‘client’.\n\nOne of: [client, federation]."
		},
		{
		  "name": "presence",
		  "type": "EventFilter",
		  "desc": "The presence updates to include."
		},
		{
		  "name": "room",
		  "type": "RoomFilter",
		  "desc": "Filters to be applied to room data."
		}
	  ],
	  "EventFilter": [
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		}
	  ],
	  "RoomFilter": [
		{
		  "name": "account_data",
		  "type": "RoomEventFilter",
		  "desc": "The per user account data to include for rooms."
		},
		{
		  "name": "ephemeral",
		  "type": "RoomEventFilter",
		  "desc": "The ephemeral events to include for rooms. These are the events that appear in the ephemeral property in the /sync response."
		},
		{
		  "name": "include_leave",
		  "type": "boolean",
		  "desc": "Include rooms that the user has left in the sync, default false"
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter. This filter is applied before the filters in ephemeral, state, timeline or account_data"
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ephemeral, state, timeline or account_data"
		},
		{
		  "name": "state",
		  "type": "StateFilter",
		  "desc": "The state events to include for rooms."
		},
		{
		  "name": "timeline",
		  "type": "RoomEventFilter",
		  "desc": "The message and state update events to include for rooms."
		}
	  ],
	  "RoomEventFilter": [
		{
		  "name": "contains_url",
		  "type": "boolean",
		  "desc": "If true, includes only events with a url key in their content. If false, excludes those events. If omitted, url key is not considered for filtering."
		},
		{
		  "name": "include_redundant_members",
		  "type": "boolean",
		  "desc": "If true, sends all membership events for all events, even if they have already been sent to the client. Does not apply unless lazy_load_members is true. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "lazy_load_members",
		  "type": "boolean",
		  "desc": "If true, enables lazy-loading of membership events. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "unread_thread_notifications",
		  "type": "boolean",
		  "desc": "If true, enables per-thread notification counts. Only applies to the /sync endpoint. Defaults to false.\n\nAdded in v1.4"
		}
	  ],
	  "StateFilter": [
		{
		  "name": "contains_url",
		  "type": "boolean",
		  "desc": "If true, includes only events with a url key in their content. If false, excludes those events. If omitted, url key is not considered for filtering."
		},
		{
		  "name": "include_redundant_members",
		  "type": "boolean",
		  "desc": "If true, sends all membership events for all events, even if they have already been sent to the client. Does not apply unless lazy_load_members is true. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "lazy_load_members",
		  "type": "boolean",
		  "desc": "If true, enables lazy-loading of membership events. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "unread_thread_notifications",
		  "type": "boolean",
		  "desc": "If true, enables per-thread notification counts. Only applies to the /sync endpoint. Defaults to false.\n\nAdded in v1.4"
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/filter/{filterId}",
	  "path parameters": [
		{
		  "name": "filterId",
		  "type": "string",
		  "desc": "Required: The filter ID to download."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user ID to download a filter for."
		}
	  ],
	  "Filter": [
		{
		  "name": "account_data",
		  "type": "EventFilter",
		  "desc": "The user account data that isn’t associated with rooms to include."
		},
		{
		  "name": "event_fields",
		  "type": "[string]",
		  "desc": "List of event fields to include. If this list is absent then all fields are included. The entries are dot-separated paths for each property to include. So [‘content.body’] will include the ‘body’ field of the ‘content’ object. A server may include more fields than were requested."
		},
		{
		  "name": "event_format",
		  "type": "string",
		  "desc": "The format to use for events. ‘client’ will return the events in a format suitable for clients. ‘federation’ will return the raw event as received over federation. The default is ‘client’.\n\nOne of: [client, federation]."
		},
		{
		  "name": "presence",
		  "type": "EventFilter",
		  "desc": "The presence updates to include."
		},
		{
		  "name": "room",
		  "type": "RoomFilter",
		  "desc": "Filters to be applied to room data."
		}
	  ],
	  "EventFilter": [
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		}
	  ],
	  "RoomFilter": [
		{
		  "name": "account_data",
		  "type": "RoomEventFilter",
		  "desc": "The per user account data to include for rooms."
		},
		{
		  "name": "ephemeral",
		  "type": "RoomEventFilter",
		  "desc": "The ephemeral events to include for rooms. These are the events that appear in the ephemeral property in the /sync response."
		},
		{
		  "name": "include_leave",
		  "type": "boolean",
		  "desc": "Include rooms that the user has left in the sync, default false"
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter. This filter is applied before the filters in ephemeral, state, timeline or account_data"
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ephemeral, state, timeline or account_data"
		},
		{
		  "name": "state",
		  "type": "StateFilter",
		  "desc": "The state events to include for rooms."
		},
		{
		  "name": "timeline",
		  "type": "RoomEventFilter",
		  "desc": "The message and state update events to include for rooms."
		}
	  ],
	  "RoomEventFilter": [
		{
		  "name": "contains_url",
		  "type": "boolean",
		  "desc": "If true, includes only events with a url key in their content. If false, excludes those events. If omitted, url key is not considered for filtering."
		},
		{
		  "name": "include_redundant_members",
		  "type": "boolean",
		  "desc": "If true, sends all membership events for all events, even if they have already been sent to the client. Does not apply unless lazy_load_members is true. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "lazy_load_members",
		  "type": "boolean",
		  "desc": "If true, enables lazy-loading of membership events. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "unread_thread_notifications",
		  "type": "boolean",
		  "desc": "If true, enables per-thread notification counts. Only applies to the /sync endpoint. Defaults to false.\n\nAdded in v1.4"
		}
	  ],
	  "StateFilter": [
		{
		  "name": "contains_url",
		  "type": "boolean",
		  "desc": "If true, includes only events with a url key in their content. If false, excludes those events. If omitted, url key is not considered for filtering."
		},
		{
		  "name": "include_redundant_members",
		  "type": "boolean",
		  "desc": "If true, sends all membership events for all events, even if they have already been sent to the client. Does not apply unless lazy_load_members is true. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "lazy_load_members",
		  "type": "boolean",
		  "desc": "If true, enables lazy-loading of membership events. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "unread_thread_notifications",
		  "type": "boolean",
		  "desc": "If true, enables per-thread notification counts. Only applies to the /sync endpoint. Defaults to false.\n\nAdded in v1.4"
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/sync",
	  "query parameters": [
		{
		  "name": "filter",
		  "type": "string",
		  "desc": "The ID of a filter created using the filter API or a filter JSON object encoded as a string. The server will detect whether it is an ID or a JSON object by whether the first character is a \"{\" open brace. Passing the JSON inline is best suited to one off requests. Creating a filter using the filter API is recommended for clients that reuse the same filter multiple times, for example in long poll requests.\n\nSee Filtering for more information."
		},
		{
		  "name": "full_state",
		  "type": "boolean",
		  "desc": "Controls whether to include the full state for all rooms the user is a member of.\n\nIf this is set to true, then all state events will be returned, even if since is non-empty. The timeline will still be limited by the since parameter. In this case, the timeout parameter will be ignored and the query will return immediately, possibly with an empty timeline.\n\nIf false, and since is non-empty, only state which has changed since the point indicated by since will be returned.\n\nBy default, this is false."
		},
		{
		  "name": "set_presence",
		  "type": "string",
		  "desc": "Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to “offline” then the client is not marked as being online when it uses this API. When set to “unavailable”, the client is marked as being idle.\n\nOne of: [offline, online, unavailable]."
		},
		{
		  "name": "since",
		  "type": "string",
		  "desc": "A point in time to continue a sync from. This should be the next_batch token returned by an earlier call to this endpoint."
		},
		{
		  "name": "timeout",
		  "type": "integer",
		  "desc": "The maximum time to wait, in milliseconds, before returning this request. If no events (or other data) become available before this time elapses, the server will return a response with empty fields.\n\nBy default, this is 0, so the server will return immediately even if the response is empty."
		}
	  ],
	  "Account Data": [
		{
		  "name": "events",
		  "type": "[Event]",
		  "desc": "List of events."
		}
	  ],
	  "Event": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. ‘com.example.subdomain.event.type’"
		}
	  ],
	  "Presence": [
		{
		  "name": "events",
		  "type": "[Event]",
		  "desc": "List of events."
		}
	  ],
	  "Rooms": [
		{
		  "name": "invite",
		  "type": "Invited Rooms",
		  "desc": "The rooms that the user has been invited to, mapped as room ID to room information."
		},
		{
		  "name": "join",
		  "type": "Joined Rooms",
		  "desc": "The rooms that the user has joined, mapped as room ID to room information."
		},
		{
		  "name": "knock",
		  "type": "Knocked rooms",
		  "desc": "The rooms that the user has knocked upon, mapped as room ID to room information."
		},
		{
		  "name": "leave",
		  "type": "Left rooms",
		  "desc": "The rooms that the user has left or been banned from, mapped as room ID to room information."
		}
	  ],
	  "Invited Room": [
		{
		  "name": "invite_state",
		  "type": "InviteState",
		  "desc": "The stripped state of a room that the user has been invited to."
		}
	  ],
	  "InviteState": [
		{
		  "name": "events",
		  "type": "[StrippedStateEvent]",
		  "desc": "The stripped state events that form the invite state."
		}
	  ],
	  "StrippedStateEvent": [
		{
		  "name": "content",
		  "type": "EventContent",
		  "desc": "Required: The content for the event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: The sender for the event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Required: The state_key for the event."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type for the event."
		}
	  ],
	  "Joined Room": [
		{
		  "name": "account_data",
		  "type": "Account Data",
		  "desc": "The private data that this user has attached to this room."
		},
		{
		  "name": "ephemeral",
		  "type": "Ephemeral",
		  "desc": "The new ephemeral events in the room (events that aren’t recorded in the timeline or state of the room). In this version of the spec, these are typing notification and read receipt events."
		},
		{
		  "name": "state",
		  "type": "State",
		  "desc": "Updates to the state, between the time indicated by the since parameter, and the start of the timeline (or all state up to the start of the timeline, if since is not given, or full_state is true).\n\nN.B. state updates for m.room.member events will be incomplete if lazy_load_members is enabled in the /sync filter, and only return the member events required to display the senders of the timeline events in this response."
		},
		{
		  "name": "summary",
		  "type": "RoomSummary",
		  "desc": "Information about the room which clients may need to correctly render it to users."
		},
		{
		  "name": "timeline",
		  "type": "Timeline",
		  "desc": "The timeline of messages and state changes in the room."
		},
		{
		  "name": "unread_notifications",
		  "type": "Unread Notification Counts",
		  "desc": "Counts of unread notifications for this room. See the Receiving notifications section for more information on how these are calculated.\n\nIf unread_thread_notifications was specified as true on the RoomEventFilter, these counts will only be for the main timeline rather than all events in the room. See the threading module for more information.\n\n\n\nChanged in v1.4: Updated to reflect behaviour of having unread_thread_notifications as true in the RoomEventFilter for /sync."
		},
		{
		  "name": "unread_thread_notifications",
		  "type": "Unread Thread Notification Counts",
		  "desc": "If unread_thread_notifications was specified as true on the RoomEventFilter, the notification counts for each thread in this room. The object is keyed by thread root ID, with values matching unread_notifications.\n\nIf a thread does not have any notifications it can be omitted from this object. If no threads have notification counts, this whole object can be omitted.\n\nAdded in v1.4"
		}
	  ],
	  "Ephemeral": [
		{
		  "name": "events",
		  "type": "[Event]",
		  "desc": "List of events."
		}
	  ],
	  "State": [
		{
		  "name": "events",
		  "type": "[ClientEventWithoutRoomID]",
		  "desc": "List of events."
		}
	  ],
	  "ClientEventWithoutRoomID": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEventWithoutRoomID",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "RoomSummary": [
		{
		  "name": "m.heroes",
		  "type": "[string]",
		  "desc": "The users which can be used to generate a room name if the room does not have one. Required if the room’s m.room.name or m.room.canonical_alias state events are unset or empty.\n\nThis should be the first 5 members of the room, ordered by stream ordering, which are joined or invited. The list must never include the client’s own user ID. When no joined or invited members are available, this should consist of the banned and left users. More than 5 members may be provided, however less than 5 should only be provided when there are less than 5 members to represent.\n\nWhen lazy-loading room members is enabled, the membership events for the heroes MUST be included in the state, unless they are redundant. When the list of users changes, the server notifies the client by sending a fresh list of heroes. If there are no changes since the last sync, this field may be omitted."
		},
		{
		  "name": "m.invited_member_count",
		  "type": "integer",
		  "desc": "The number of users with membership of invite. If this field has not changed since the last sync, it may be omitted. Required otherwise."
		},
		{
		  "name": "m.joined_member_count",
		  "type": "integer",
		  "desc": "The number of users with membership of join, including the client’s own user ID. If this field has not changed since the last sync, it may be omitted. Required otherwise."
		}
	  ],
	  "Timeline": [
		{
		  "name": "events",
		  "type": "[ClientEventWithoutRoomID]",
		  "desc": "Required: List of events."
		},
		{
		  "name": "limited",
		  "type": "boolean",
		  "desc": "True if the number of events returned was limited by the limit on the filter."
		},
		{
		  "name": "prev_batch",
		  "type": "string",
		  "desc": "A token that can be supplied to the from parameter of the /rooms/<room_id>/messages endpoint in order to retrieve earlier events. If no earlier events are available, this property may be omitted from the response."
		}
	  ],
	  "Unread Notification Counts": [
		{
		  "name": "highlight_count",
		  "type": "integer",
		  "desc": "The number of unread notifications for this room with the highlight flag set."
		},
		{
		  "name": "notification_count",
		  "type": "integer",
		  "desc": "The total number of unread notifications for this room."
		}
	  ],
	  "ThreadNotificationCounts": [
		{
		  "name": "highlight_count",
		  "type": "integer",
		  "desc": "The number of unread notifications for this thread with the highlight flag set."
		},
		{
		  "name": "notification_count",
		  "type": "integer",
		  "desc": "The total number of unread notifications for this thread."
		}
	  ],
	  "Knocked Room": [
		{
		  "name": "knock_state",
		  "type": "KnockState",
		  "desc": "The stripped state of a room that the user has knocked upon."
		}
	  ],
	  "KnockState": [
		{
		  "name": "events",
		  "type": "[StrippedStateEvent]",
		  "desc": "The stripped state events that form the knock state."
		}
	  ],
	  "Left Room": [
		{
		  "name": "account_data",
		  "type": "Account Data",
		  "desc": "The private data that this user has attached to this room."
		},
		{
		  "name": "state",
		  "type": "State",
		  "desc": "The state updates for the room up to the start of the timeline."
		},
		{
		  "name": "timeline",
		  "type": "Timeline",
		  "desc": "The timeline of messages and state changes in the room up to the point when the user left."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/events",
	  "query parameters": [
		{
		  "name": "from",
		  "type": "string",
		  "desc": "The token to stream from. This token is either from a previous request to this API or from the initial sync API."
		},
		{
		  "name": "timeout",
		  "type": "integer",
		  "desc": "The maximum time in milliseconds to wait for an event."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/events/{eventId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The event ID to get."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/initialSync",
	  "query parameters": [
		{
		  "name": "archived",
		  "type": "boolean",
		  "desc": "Whether to include rooms that the user has left. If false then only rooms that the user has been invited to or has joined are included. If set to true then rooms that the user has left are included as well. By default this is false."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of messages to return for each room."
		}
	  ],
	  "Event": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. ‘com.example.subdomain.event.type’"
		}
	  ],
	  "RoomInfo": [
		{
		  "name": "account_data",
		  "type": "[Event]",
		  "desc": "The private data that this user has attached to this room."
		},
		{
		  "name": "invite",
		  "type": "InviteEvent",
		  "desc": "The invite event if membership is invite"
		},
		{
		  "name": "membership",
		  "type": "string",
		  "desc": "Required: The user’s membership state in this room.\n\nOne of: [invite, join, leave, ban]."
		},
		{
		  "name": "messages",
		  "type": "PaginationChunk",
		  "desc": "The pagination chunk for this room."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of this room."
		},
		{
		  "name": "state",
		  "type": "[ClientEvent]",
		  "desc": "If the user is a member of the room this will be the current state of the room as a list of events. If the user has left the room this will be the state of the room when they left it."
		},
		{
		  "name": "visibility",
		  "type": "string",
		  "desc": "Whether this room is visible to the /publicRooms API or not.\"\n\nOne of: [private, public]."
		}
	  ],
	  "InviteEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "PaginationChunk": [
		{
		  "name": "chunk",
		  "type": "[ClientEvent]",
		  "desc": "Required: If the user is a member of the room this will be a list of the most recent messages for this room. If the user has left the room this will be the messages that preceded them leaving. This array will consist of at most limit elements."
		},
		{
		  "name": "end",
		  "type": "string",
		  "desc": "Required: A token which correlates to the end of chunk. Can be passed to /rooms/<room_id>/messages to retrieve later events."
		},
		{
		  "name": "start",
		  "type": "string",
		  "desc": "A token which correlates to the start of chunk. Can be passed to /rooms/<room_id>/messages to retrieve earlier events.\n\nIf no earlier events are available, this property may be omitted from the response."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/event/{eventId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The event ID to get."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room the event is in."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/joined_members",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to get the members of."
		}
	  ],
	  "RoomMember": [
		{
		  "name": "avatar_url",
		  "type": "string",
		  "desc": "The avatar of the user this object is representing, as an mxc:// URI."
		},
		{
		  "name": "display_name",
		  "type": "string",
		  "desc": "The display name of the user this object is representing."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/members",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to get the member events for."
		}
	  ],
	  "query parameters": [
		{
		  "name": "at",
		  "type": "string",
		  "desc": "The point in time (pagination token) to return members for in the room. This token can be obtained from a prev_batch token returned for each room by the sync API. Defaults to the current state of the room, as determined by the server."
		},
		{
		  "name": "membership",
		  "type": "string",
		  "desc": "The kind of membership to filter for. Defaults to no filtering if unspecified. When specified alongside not_membership, the two parameters create an ‘or’ condition: either the membership is the same as membership or is not the same as not_membership.\n\nOne of: [join, invite, knock, leave, ban]."
		},
		{
		  "name": "not_membership",
		  "type": "string",
		  "desc": "The kind of membership to exclude from the results. Defaults to no filtering if unspecified.\n\nOne of: [join, invite, knock, leave, ban]."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/state",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to look up the state for."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/state/{eventType}/{stateKey}",
	  "path parameters": [
		{
		  "name": "eventType",
		  "type": "string",
		  "desc": "Required: The type of state to look up."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to look up the state in."
		},
		{
		  "name": "stateKey",
		  "type": "string",
		  "desc": "Required: The key of the state to look up. Defaults to an empty string. When an empty string, the trailing slash on this endpoint is optional."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/messages",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to get events from."
		}
	  ],
	  "query parameters": [
		{
		  "name": "dir",
		  "type": "string",
		  "desc": "Required: The direction to return events from. If this is set to f, events will be returned in chronological order starting at from. If it is set to b, events will be returned in reverse chronological order, again starting at from.\n\nOne of: [b, f]."
		},
		{
		  "name": "filter",
		  "type": "string",
		  "desc": "A JSON RoomEventFilter to filter returned events with."
		},
		{
		  "name": "from",
		  "type": "string",
		  "desc": "The token to start returning events from. This token can be obtained from a prev_batch or next_batch token returned by the /sync endpoint, or from an end token returned by a previous request to this endpoint.\n\nThis endpoint can also accept a value returned as a start token by a previous request to this endpoint, though servers are not required to support this. Clients should not rely on the behaviour.\n\nIf it is not provided, the homeserver shall return a list of messages from the first or last (per the value of the dir parameter) visible event in the room history for the requesting user.\n\n\n\nChanged in v1.3: Previously, this field was required and paginating from the first or last visible event in the room history wasn’t supported."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return. Default: 10."
		},
		{
		  "name": "to",
		  "type": "string",
		  "desc": "The token to stop returning events at. This token can be obtained from a prev_batch or next_batch token returned by the /sync endpoint, or from an end token returned by a previous request to this endpoint."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/rooms/{roomId}/timestamp_to_event",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to search"
		}
	  ],
	  "query parameters": [
		{
		  "name": "dir",
		  "type": "string",
		  "desc": "Required: The direction in which to search. f for forwards, b for backwards.\n\nOne of: [f, b]."
		},
		{
		  "name": "ts",
		  "type": "integer",
		  "desc": "Required: The timestamp to search from, as given in milliseconds since the Unix epoch."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/initialSync",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to get the data."
		}
	  ],
	  "RoomInfo": [
		{
		  "name": "account_data",
		  "type": "[Event]",
		  "desc": "The private data that this user has attached to this room."
		},
		{
		  "name": "membership",
		  "type": "string",
		  "desc": "The user’s membership state in this room.\n\nOne of: [invite, join, leave, ban]."
		},
		{
		  "name": "messages",
		  "type": "PaginationChunk",
		  "desc": "The pagination chunk for this room."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of this room."
		},
		{
		  "name": "state",
		  "type": "[ClientEvent]",
		  "desc": "If the user is a member of the room this will be the current state of the room as a list of events. If the user has left the room this will be the state of the room when they left it."
		},
		{
		  "name": "visibility",
		  "type": "string",
		  "desc": "Whether this room is visible to the /publicRooms API or not.\"\n\nOne of: [private, public]."
		}
	  ],
	  "Event": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. ‘com.example.subdomain.event.type’"
		}
	  ],
	  "PaginationChunk": [
		{
		  "name": "chunk",
		  "type": "[ClientEvent]",
		  "desc": "Required: If the user is a member of the room this will be a list of the most recent messages for this room. If the user has left the room this will be the messages that preceded them leaving. This array will consist of at most limit elements."
		},
		{
		  "name": "end",
		  "type": "string",
		  "desc": "Required: A token which correlates to the end of chunk. Can be passed to /rooms/<room_id>/messages to retrieve later events."
		},
		{
		  "name": "start",
		  "type": "string",
		  "desc": "A token which correlates to the start of chunk. Can be passed to /rooms/<room_id>/messages to retrieve earlier events.\n\nIf no earlier events are available, this property may be omitted from the response."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/state/{eventType}/{stateKey}",
	  "path parameters": [
		{
		  "name": "eventType",
		  "type": "string",
		  "desc": "Required: The type of event to send."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to set the state in"
		},
		{
		  "name": "stateKey",
		  "type": "string",
		  "desc": "Required: The state_key for the state to send. Defaults to the empty string. When an empty string, the trailing slash on this endpoint is optional."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}",
	  "path parameters": [
		{
		  "name": "eventType",
		  "type": "string",
		  "desc": "Required: The type of event to send."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to send the event to."
		},
		{
		  "name": "txnId",
		  "type": "string",
		  "desc": "Required: The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/redact/{eventId}/{txnId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The ID of the event to redact"
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room from which to redact the event."
		},
		{
		  "name": "txnId",
		  "type": "string",
		  "desc": "Required: The transaction ID for this event. Clients should generate a unique ID; it will be used by the server to ensure idempotency of requests."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/rooms/{roomId}/relations/{eventId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The ID of the parent event whose child events are to be returned."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room containing the parent event."
		}
	  ],
	  "query parameters": [
		{
		  "name": "dir",
		  "type": "string",
		  "desc": "Optional (default b) direction to return events from. If this is set to f, events will be returned in chronological order starting at from. If it is set to b, events will be returned in reverse chronological order, again starting at from.\n\nOne of: [b, f].\n\nAdded in v1.4"
		},
		{
		  "name": "from",
		  "type": "string",
		  "desc": "The pagination token to start returning results from. If not supplied, results start at the most recent topological event known to the server.\n\nCan be a next_batch or prev_batch token from a previous call, or a returned start token from /messages, or a next_batch token from /sync."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of results to return in a single chunk. The server can and should apply a maximum value to this parameter to avoid large responses.\n\nSimilarly, the server should apply a default value when not supplied."
		},
		{
		  "name": "recurse",
		  "type": "boolean",
		  "desc": "Whether to additionally include events which only relate indirectly to the given event, i.e. events related to the given event via two or more direct relationships.\n\nIf set to false, only events which have direct a relation with the given event will be included.\n\nIf set to true, all events which relate to the given event, or relate to events that relate to the given event, will be included.\n\nIt is recommended that homeservers traverse at least 3 levels of relationships. Implementations may perform more but should be careful to not infinitely recurse.\n\nThe default value is false.\n\nAdded in v1.10"
		},
		{
		  "name": "to",
		  "type": "string",
		  "desc": "The pagination token to stop returning results at. If not supplied, results continue up to limit or until there are no more events.\n\nLike from, this can be a previous token from a prior call to this endpoint or from /messages or /sync."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/rooms/{roomId}/relations/{eventId}/{relType}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The ID of the parent event whose child events are to be returned."
		},
		{
		  "name": "relType",
		  "type": "string",
		  "desc": "Required: The relationship type to search for."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room containing the parent event."
		}
	  ],
	  "query parameters": [
		{
		  "name": "dir",
		  "type": "string",
		  "desc": "Optional (default b) direction to return events from. If this is set to f, events will be returned in chronological order starting at from. If it is set to b, events will be returned in reverse chronological order, again starting at from.\n\nOne of: [b, f].\n\nAdded in v1.4"
		},
		{
		  "name": "from",
		  "type": "string",
		  "desc": "The pagination token to start returning results from. If not supplied, results start at the most recent topological event known to the server.\n\nCan be a next_batch or prev_batch token from a previous call, or a returned start token from /messages, or a next_batch token from /sync."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of results to return in a single chunk. The server can and should apply a maximum value to this parameter to avoid large responses.\n\nSimilarly, the server should apply a default value when not supplied."
		},
		{
		  "name": "recurse",
		  "type": "boolean",
		  "desc": "Whether to additionally include events which only relate indirectly to the given event, i.e. events related to the given event via two or more direct relationships.\n\nIf set to false, only events which have direct a relation with the given event will be included.\n\nIf set to true, all events which relate to the given event, or relate to events that relate to the given event, will be included.\n\nIt is recommended that homeservers traverse at least 3 levels of relationships. Implementations may perform more but should be careful to not infinitely recurse.\n\nThe default value is false.\n\nAdded in v1.10"
		},
		{
		  "name": "to",
		  "type": "string",
		  "desc": "The pagination token to stop returning results at. If not supplied, results continue up to limit or until there are no more events.\n\nLike from, this can be a previous token from a prior call to this endpoint or from /messages or /sync."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/rooms/{roomId}/relations/{eventId}/{relType}/{eventType}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The ID of the parent event whose child events are to be returned."
		},
		{
		  "name": "eventType",
		  "type": "string",
		  "desc": "Required:\n\nThe event type of child events to search for.\n\nNote that in encrypted rooms this will typically always be m.room.encrypted regardless of the event type contained within the encrypted payload."
		},
		{
		  "name": "relType",
		  "type": "string",
		  "desc": "Required: The relationship type to search for."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room containing the parent event."
		}
	  ],
	  "query parameters": [
		{
		  "name": "dir",
		  "type": "string",
		  "desc": "Optional (default b) direction to return events from. If this is set to f, events will be returned in chronological order starting at from. If it is set to b, events will be returned in reverse chronological order, again starting at from.\n\nOne of: [b, f].\n\nAdded in v1.4"
		},
		{
		  "name": "from",
		  "type": "string",
		  "desc": "The pagination token to start returning results from. If not supplied, results start at the most recent topological event known to the server.\n\nCan be a next_batch or prev_batch token from a previous call, or a returned start token from /messages, or a next_batch token from /sync."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of results to return in a single chunk. The server can and should apply a maximum value to this parameter to avoid large responses.\n\nSimilarly, the server should apply a default value when not supplied."
		},
		{
		  "name": "recurse",
		  "type": "boolean",
		  "desc": "Whether to additionally include events which only relate indirectly to the given event, i.e. events related to the given event via two or more direct relationships.\n\nIf set to false, only events which have direct a relation with the given event will be included.\n\nIf set to true, all events which relate to the given event, or relate to events that relate to the given event, will be included.\n\nIt is recommended that homeservers traverse at least 3 levels of relationships. Implementations may perform more but should be careful to not infinitely recurse.\n\nThe default value is false.\n\nAdded in v1.10"
		},
		{
		  "name": "to",
		  "type": "string",
		  "desc": "The pagination token to stop returning results at. If not supplied, results continue up to limit or until there are no more events.\n\nLike from, this can be a previous token from a prior call to this endpoint or from /messages or /sync."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/createRoom",
	  "StateEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The content of the event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "The state_key of the state event. Defaults to an empty string."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of event to send."
		}
	  ],
	  "Invite3pid": [
		{
		  "name": "address",
		  "type": "string",
		  "desc": "Required: The invitee’s third-party identifier."
		},
		{
		  "name": "id_access_token",
		  "type": "string",
		  "desc": "Required: An access token previously registered with the identity server. Servers can treat this as optional to distinguish between r0.5-compatible clients and this specification version."
		},
		{
		  "name": "id_server",
		  "type": "string",
		  "desc": "Required: The hostname+port of the identity server which should be used for third-party identifier lookups."
		},
		{
		  "name": "medium",
		  "type": "string",
		  "desc": "Required: The kind of address being passed in the address field, for example email (see the list of recognised values)."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/directory/room/{roomAlias}",
	  "path parameters": [
		{
		  "name": "roomAlias",
		  "type": "string",
		  "desc": "Required: The room alias. Its format is defined in the appendices."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/directory/room/{roomAlias}",
	  "path parameters": [
		{
		  "name": "roomAlias",
		  "type": "string",
		  "desc": "Required: The room alias to set. Its format is defined in the appendices."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/directory/room/{roomAlias}",
	  "path parameters": [
		{
		  "name": "roomAlias",
		  "type": "string",
		  "desc": "Required: The room alias to remove. Its format is defined in the appendices."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/aliases",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room ID to find local aliases of."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/joined_rooms"
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/invite ",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier (not alias) to which to invite the user."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/join/{roomIdOrAlias}",
	  "path parameters": [
		{
		  "name": "roomIdOrAlias",
		  "type": "string",
		  "desc": "Required: The room identifier or alias to join."
		}
	  ],
	  "query parameters": [
		{
		  "name": "server_name",
		  "type": "[string]",
		  "desc": "The servers to attempt to join the room through. One of the servers must be participating in the room."
		}
	  ],
	  "Third-party Signed": [
		{
		  "name": "mxid",
		  "type": "string",
		  "desc": "Required: The Matrix ID of the invitee."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: The Matrix ID of the user who issued the invite."
		},
		{
		  "name": "signatures",
		  "type": "Signatures",
		  "desc": "Required: A signatures object containing a signature of the entire signed object."
		},
		{
		  "name": "token",
		  "type": "string",
		  "desc": "Required: The state key of the m.third_party_invite event."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/join",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier (not alias) to join."
		}
	  ],
	  "Third-party Signed": [
		{
		  "name": "mxid",
		  "type": "string",
		  "desc": "Required: The Matrix ID of the invitee."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: The Matrix ID of the user who issued the invite."
		},
		{
		  "name": "signatures",
		  "type": "Signatures",
		  "desc": "Required: A signatures object containing a signature of the entire signed object."
		},
		{
		  "name": "token",
		  "type": "string",
		  "desc": "Required: The state key of the m.third_party_invite event."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/knock/{roomIdOrAlias}",
	  "path parameters": [
		{
		  "name": "roomIdOrAlias",
		  "type": "string",
		  "desc": "Required: The room identifier or alias to knock upon."
		}
	  ],
	  "query parameters": [
		{
		  "name": "server_name",
		  "type": "[string]",
		  "desc": "The servers to attempt to knock on the room through. One of the servers must be participating in the room."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/forget",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier to forget."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/leave",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier to leave."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/kick",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier (not alias) from which the user should be kicked."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/ban",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier (not alias) from which the user should be banned."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/unban",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier (not alias) from which the user should be unbanned."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/directory/list/room/{roomId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room ID."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/directory/list/room/{roomId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room ID."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/publicRooms",
	  "query parameters": [
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "Limit the number of results returned."
		},
		{
		  "name": "server",
		  "type": "string",
		  "desc": "The server to fetch the public room lists from. Defaults to the local server. Case sensitive."
		},
		{
		  "name": "since",
		  "type": "string",
		  "desc": "A pagination token from a previous request, allowing clients to get the next (or previous) batch of rooms. The direction of pagination is specified solely by which token is supplied, rather than via an explicit flag."
		}
	  ],
	  "PublicRoomsChunk": [
		{
		  "name": "avatar_url",
		  "type": "string",
		  "desc": "The URL for the room’s avatar, if one is set."
		},
		{
		  "name": "canonical_alias",
		  "type": "string",
		  "desc": "The canonical alias of the room, if any."
		},
		{
		  "name": "guest_can_join",
		  "type": "boolean",
		  "desc": "Required: Whether guest users may join the room and participate in it. If they can, they will be subject to ordinary power level rules like any other user."
		},
		{
		  "name": "join_rule",
		  "type": "string",
		  "desc": "The room’s join rule. When not present, the room is assumed to be public. Note that rooms with invite join rules are not expected here, but rooms with knock rules are given their near-public nature."
		},
		{
		  "name": "name",
		  "type": "string",
		  "desc": "The name of the room, if any."
		},
		{
		  "name": "num_joined_members",
		  "type": "integer",
		  "desc": "Required: The number of members joined to the room."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room."
		},
		{
		  "name": "room_type",
		  "type": "string",
		  "desc": "The type of room (from m.room.create), if any.\n\nAdded in v1.4"
		},
		{
		  "name": "topic",
		  "type": "string",
		  "desc": "The topic of the room, if any."
		},
		{
		  "name": "world_readable",
		  "type": "boolean",
		  "desc": "Required: Whether the room may be viewed by guest users without joining."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/publicRooms",
	  "query parameters": [
		{
		  "name": "server",
		  "type": "string",
		  "desc": "The server to fetch the public room lists from. Defaults to the local server. Case sensitive."
		}
	  ],
	  "Filter": [
		{
		  "name": "generic_search_term",
		  "type": "string",
		  "desc": "An optional string to search for in the room metadata, e.g. name, topic, canonical alias, etc."
		},
		{
		  "name": "room_types",
		  "type": "[string|null]",
		  "desc": "An optional list of room types to search for. To include rooms without a room type, specify null within this list. When not specified, all applicable rooms (regardless of type) are returned.\n\nAdded in v1.4"
		}
	  ],
	  "PublicRoomsChunk": [
		{
		  "name": "avatar_url",
		  "type": "string",
		  "desc": "The URL for the room’s avatar, if one is set."
		},
		{
		  "name": "canonical_alias",
		  "type": "string",
		  "desc": "The canonical alias of the room, if any."
		},
		{
		  "name": "guest_can_join",
		  "type": "boolean",
		  "desc": "Required: Whether guest users may join the room and participate in it. If they can, they will be subject to ordinary power level rules like any other user."
		},
		{
		  "name": "join_rule",
		  "type": "string",
		  "desc": "The room’s join rule. When not present, the room is assumed to be public. Note that rooms with invite join rules are not expected here, but rooms with knock rules are given their near-public nature."
		},
		{
		  "name": "name",
		  "type": "string",
		  "desc": "The name of the room, if any."
		},
		{
		  "name": "num_joined_members",
		  "type": "integer",
		  "desc": "Required: The number of members joined to the room."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room."
		},
		{
		  "name": "room_type",
		  "type": "string",
		  "desc": "The type of room (from m.room.create), if any.\n\nAdded in v1.4"
		},
		{
		  "name": "topic",
		  "type": "string",
		  "desc": "The topic of the room, if any."
		},
		{
		  "name": "world_readable",
		  "type": "boolean",
		  "desc": "Required: Whether the room may be viewed by guest users without joining."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user_directory/search",
	  "User": [
		{
		  "name": "avatar_url",
		  "type": "string",
		  "desc": "The avatar url, as an mxc:// URI, if one exists."
		},
		{
		  "name": "display_name",
		  "type": "string",
		  "desc": "The display name of the user, if one exists."
		},
		{
		  "name": "user_id",
		  "type": "string",
		  "desc": "Required: The user’s matrix user ID."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/profile/{userId}",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose profile information to get."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/profile/{userId}/avatar_url",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose avatar URL to get."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/profile/{userId}/avatar_url",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose avatar URL to set."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/profile/{userId}/displayname",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose display name to get."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/profile/{userId}/displayname",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose display name to set."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/voip/turnServer",
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/typing/{userId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room in which the user is typing."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user who has started to type."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/receipt/{receiptType}/{eventId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The event ID to acknowledge up to."
		},
		{
		  "name": "receiptType",
		  "type": "string",
		  "desc": "Required:\n\nThe type of receipt to send. This can also be m.fully_read as an alternative to /read_markers.\n\nNote that m.fully_read does not appear under m.receipt: this endpoint effectively calls /read_markers internally when presented with a receipt type of m.fully_read.\n\nOne of: [m.read, m.read.private, m.fully_read].\n\n\n\nChanged in v1.4: Allow m.read.private receipts and m.fully_read markers to be set."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room in which to send the event."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/read_markers",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room ID to set the read marker in for the user."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/presence/{userId}/status",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose presence state to get."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/presence/{userId}/status",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user whose presence state to update."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v1/create",
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/config",
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/download/{serverName}/{mediaId}",
	  "path parameters": [
		{
		  "name": "mediaId",
		  "type": "string",
		  "desc": "Required: The media ID from the mxc:// URI (the path component)"
		},
		{
		  "name": "serverName",
		  "type": "string",
		  "desc": "Required: The server name from the mxc:// URI (the authoritory component)"
		}
	  ],
	  "query parameters": [
		{
		  "name": "allow_redirect",
		  "type": "boolean",
		  "desc": "Indicates to the server that it may return a 307 or 308 redirect response that points at the relevant media content. When not explicitly set to true the server must return the media content itself.\n\nAdded in v1.7"
		},
		{
		  "name": "allow_remote",
		  "type": "boolean",
		  "desc": "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided."
		},
		{
		  "name": "timeout_ms",
		  "type": "integer",
		  "desc": "The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository can and should impose a maximum value for this parameter. The content repository may also choose to respond before the timeout.\n\nAdded in v1.7"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/download/{serverName}/{mediaId}/{fileName}",
	  "path parameters": [
		{
		  "name": "fileName",
		  "type": "string",
		  "desc": "Required: A filename to give in the Content-Disposition header."
		},
		{
		  "name": "mediaId",
		  "type": "string",
		  "desc": "Required: The media ID from the mxc:// URI (the path component)"
		},
		{
		  "name": "serverName",
		  "type": "string",
		  "desc": "Required: The server name from the mxc:// URI (the authoritory component)"
		}
	  ],
	  "query parameters": [
		{
		  "name": "allow_redirect",
		  "type": "boolean",
		  "desc": "Indicates to the server that it may return a 307 or 308 redirect response that points at the relevant media content. When not explicitly set to true the server must return the media content itself.\n\nAdded in v1.7"
		},
		{
		  "name": "allow_remote",
		  "type": "boolean",
		  "desc": "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided."
		},
		{
		  "name": "timeout_ms",
		  "type": "integer",
		  "desc": "The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository can and should impose a maximum value for this parameter. The content repository may also choose to respond before the timeout.\n\nAdded in v1.7"
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/preview_url",
	  "query parameters": [
		{
		  "name": "ts",
		  "type": "integer",
		  "desc": "The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available."
		},
		{
		  "name": "url",
		  "type": "string",
		  "desc": "Required: The URL to get a preview of."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/thumbnail/{serverName}/{mediaId}",
	  "path parameters": [
		{
		  "name": "mediaId",
		  "type": "string",
		  "desc": "Required: The media ID from the mxc:// URI (the path component)"
		},
		{
		  "name": "serverName",
		  "type": "string",
		  "desc": "Required: The server name from the mxc:// URI (the authoritory component)"
		}
	  ],
	  "query parameters": [
		{
		  "name": "allow_redirect",
		  "type": "boolean",
		  "desc": "Indicates to the server that it may return a 307 or 308 redirect response that points at the relevant media content. When not explicitly set to true the server must return the media content itself.\n\nAdded in v1.7"
		},
		{
		  "name": "allow_remote",
		  "type": "boolean",
		  "desc": "Indicates to the server that it should not attempt to fetch the media if it is deemed remote. This is to prevent routing loops where the server contacts itself. Defaults to true if not provided."
		},
		{
		  "name": "height",
		  "type": "integer",
		  "desc": "Required: The desired height of the thumbnail. The actual thumbnail may be larger than the size specified."
		},
		{
		  "name": "method",
		  "type": "string",
		  "desc": "The desired resizing method. See the Thumbnails section for more information.\n\nOne of: [crop, scale]."
		},
		{
		  "name": "timeout_ms",
		  "type": "integer",
		  "desc": "The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository can and should impose a maximum value for this parameter. The content repository may also choose to respond before the timeout.\n\nAdded in v1.7"
		},
		{
		  "name": "width",
		  "type": "integer",
		  "desc": "Required: The desired width of the thumbnail. The actual thumbnail may be larger than the size specified."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/upload",
	  "header parameters": [
		{
		  "name": "Content-Type",
		  "type": "string",
		  "desc": "The content type of the file being uploaded"
		}
	  ],
	  "query parameters": [
		{
		  "name": "filename",
		  "type": "string",
		  "desc": "The name of the file being uploaded"
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/media/v3/upload/{serverName}/{mediaId}",
	  "header parameters": [
		{
		  "name": "Content-Type",
		  "type": "string",
		  "desc": "The content type of the file being uploaded"
		}
	  ],
	  "path parameters": [
		{
		  "name": "mediaId",
		  "type": "string",
		  "desc": "Required: The media ID from the mxc:// URI returned by POST /_matrix/media/v1/create (the path component)."
		},
		{
		  "name": "serverName",
		  "type": "string",
		  "desc": "Required: The server name from the mxc:// URI returned by POST /_matrix/media/v1/create (the authoritory component)."
		}
	  ],
	  "query parameters": [
		{
		  "name": "filename",
		  "type": "string",
		  "desc": "The name of the file being uploaded"
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/sendToDevice/{eventType}/{txnId}",
	  "path parameters": [
		{
		  "name": "eventType",
		  "type": "string",
		  "desc": "Required: The type of event to send."
		},
		{
		  "name": "txnId",
		  "type": "string",
		  "desc": "Required: The transaction ID for this event. Clients should generate an ID unique across requests with the same access token; it will be used by the server to ensure idempotency of requests."
		}
	  ],
	  "body": [
		{
		  "name": "messages",
		  "type": "{string: {string: EventContent}}",
		  "desc": "Required: The messages to send. A map from user ID, to a map from device ID to message body. The device ID may also be *, meaning all known devices for the user."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/delete_devices",
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/devices",
	  "Device": [
		{
		  "name": "device_id",
		  "type": "string",
		  "desc": "Required: Identifier of this device."
		},
		{
		  "name": "display_name",
		  "type": "string",
		  "desc": "Display name set by the user for this device. Absent if no name has been set."
		},
		{
		  "name": "last_seen_ip",
		  "type": "string",
		  "desc": "The IP address where this device was last seen. (May be a few minutes out of date, for efficiency reasons)."
		},
		{
		  "name": "last_seen_ts",
		  "type": "integer",
		  "desc": "The timestamp (in milliseconds since the unix epoch) when this devices was last seen. (May be a few minutes out of date, for efficiency reasons)."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/devices/{deviceId}",
	  "path parameters": [
		{
		  "name": "deviceId",
		  "type": "string",
		  "desc": "Required: The device to retrieve."
		}
	  ],
	  "Device": [
		{
		  "name": "device_id",
		  "type": "string",
		  "desc": "Required: Identifier of this device."
		},
		{
		  "name": "display_name",
		  "type": "string",
		  "desc": "Display name set by the user for this device. Absent if no name has been set."
		},
		{
		  "name": "last_seen_ip",
		  "type": "string",
		  "desc": "The IP address where this device was last seen. (May be a few minutes out of date, for efficiency reasons)."
		},
		{
		  "name": "last_seen_ts",
		  "type": "integer",
		  "desc": "The timestamp (in milliseconds since the unix epoch) when this devices was last seen. (May be a few minutes out of date, for efficiency reasons)."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/devices/{deviceId}",
	  "path parameters": [
		{
		  "name": "deviceId",
		  "type": "string",
		  "desc": "Required: The device to update."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/devices/{deviceId}",
	  "path parameters": [
		{
		  "name": "deviceId",
		  "type": "string",
		  "desc": "Required: The device to delete."
		}
	  ],
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "Authentication response": [
		{
		  "name": "completed",
		  "type": "[string]",
		  "desc": "A list of the stages the client has completed successfully"
		},
		{
		  "name": "flows",
		  "type": "[Flow information]",
		  "desc": "Required: A list of the login flows supported by the server for this API."
		},
		{
		  "name": "params",
		  "type": "{string: object}",
		  "desc": "Contains any information that the client will need to know in order to use a given type of authentication. For each login type presented, that type may be present as a key in this dictionary. For example, the public part of an OAuth client ID could be given here."
		},
		{
		  "name": "session",
		  "type": "string",
		  "desc": "This is a session identifier that the client must pass back to the home server, if one is provided, in subsequent attempts to authenticate in the same API call."
		}
	  ],
	  "Flow information": [
		{
		  "name": "stages",
		  "type": "[string]",
		  "desc": "Required: The login type of each of the stages required to complete this authentication flow"
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/keys/device_signing/upload",
	  "Authentication Data": [
		{
		  "name": "session",
		  "type": "string",
		  "desc": "The value of the session key given by the homeserver."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "The authentication type that the client is attempting to complete. May be omitted if session is given, and the client is reissuing a request which it believes has been completed out-of-band (for example, via the fallback mechanism)."
		}
	  ],
	  "CrossSigningKey": [
		{
		  "name": "keys",
		  "type": "{string: string}",
		  "desc": "Required: The public key. The object must have exactly one property, whose name is in the form <algorithm>:<unpadded_base64_public_key>, and whose value is the unpadded base64 public key."
		},
		{
		  "name": "signatures",
		  "type": "Signatures",
		  "desc": "Signatures of the key, calculated using the process described at Signing JSON. Optional for the master key. Other keys must be signed by the user's master key."
		},
		{
		  "name": "usage",
		  "type": "[string]",
		  "desc": "Required: What the key is used for."
		},
		{
		  "name": "user_id",
		  "type": "string",
		  "desc": "Required: The ID of the user the key belongs to."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/keys/signatures/upload"
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys",
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup from which to retrieve the keys."
		}
	  ],
	  "RoomKeyBackup": [
		{
		  "name": "sessions",
		  "type": "{string: KeyBackupData}",
		  "desc": "Required: A map of session IDs to key data."
		}
	  ],
	  "KeyBackupData": [
		{
		  "name": "first_message_index",
		  "type": "integer",
		  "desc": "Required: The index of the first message in the session that the key can decrypt."
		},
		{
		  "name": "forwarded_count",
		  "type": "integer",
		  "desc": "Required: The number of times this key has been forwarded via key-sharing between devices."
		},
		{
		  "name": "is_verified",
		  "type": "boolean",
		  "desc": "Required: Whether the device backing up the key verified the device that the key is from."
		},
		{
		  "name": "session_data",
		  "type": "object",
		  "desc": "Required: Algorithm-dependent data. See the documentation for the backup algorithms in Server-side key backups for more information on the expected format of the data."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys",
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup in which to store the keys. Must be the current backup."
		}
	  ],
	  "RoomKeyBackup": [
		{
		  "name": "sessions",
		  "type": "{string: KeyBackupData}",
		  "desc": "Required: A map of session IDs to key data."
		}
	  ],
	  "KeyBackupData": [
		{
		  "name": "first_message_index",
		  "type": "integer",
		  "desc": "Required: The index of the first message in the session that the key can decrypt."
		},
		{
		  "name": "forwarded_count",
		  "type": "integer",
		  "desc": "Required: The number of times this key has been forwarded via key-sharing between devices."
		},
		{
		  "name": "is_verified",
		  "type": "boolean",
		  "desc": "Required: Whether the device backing up the key verified the device that the key is from."
		},
		{
		  "name": "session_data",
		  "type": "object",
		  "desc": "Required: Algorithm-dependent data. See the documentation for the backup algorithms in Server-side key backups for more information on the expected format of the data."
		}
	  ],
	  "RoomKeysUpdateResponse": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "Required: The number of keys stored in the backup"
		},
		{
		  "name": "etag",
		  "type": "string",
		  "desc": "Required: The new etag value representing stored keys in the backup. See GET /room_keys/version/{version} for more details."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys",
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup from which to delete the key"
		}
	  ],
	  "RoomKeysUpdateResponse": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "Required: The number of keys stored in the backup"
		},
		{
		  "name": "etag",
		  "type": "string",
		  "desc": "Required: The new etag value representing stored keys in the backup. See GET /room_keys/version/{version} for more details."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys/{roomId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room that the requested key is for."
		}
	  ],
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup from which to retrieve the key."
		}
	  ],
	  "RoomKeyBackup": [
		{
		  "name": "sessions",
		  "type": "{string: KeyBackupData}",
		  "desc": "Required: A map of session IDs to key data."
		}
	  ],
	  "KeyBackupData": [
		{
		  "name": "first_message_index",
		  "type": "integer",
		  "desc": "Required: The index of the first message in the session that the key can decrypt."
		},
		{
		  "name": "forwarded_count",
		  "type": "integer",
		  "desc": "Required: The number of times this key has been forwarded via key-sharing between devices."
		},
		{
		  "name": "is_verified",
		  "type": "boolean",
		  "desc": "Required: Whether the device backing up the key verified the device that the key is from."
		},
		{
		  "name": "session_data",
		  "type": "object",
		  "desc": "Required: Algorithm-dependent data. See the documentation for the backup algorithms in Server-side key backups for more information on the expected format of the data."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys/{roomId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room that the keys are for."
		}
	  ],
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup in which to store the keys. Must be the current backup."
		}
	  ],
	  "RoomKeyBackup": [
		{
		  "name": "sessions",
		  "type": "{string: KeyBackupData}",
		  "desc": "Required: A map of session IDs to key data."
		}
	  ],
	  "KeyBackupData": [
		{
		  "name": "first_message_index",
		  "type": "integer",
		  "desc": "Required: The index of the first message in the session that the key can decrypt."
		},
		{
		  "name": "forwarded_count",
		  "type": "integer",
		  "desc": "Required: The number of times this key has been forwarded via key-sharing between devices."
		},
		{
		  "name": "is_verified",
		  "type": "boolean",
		  "desc": "Required: Whether the device backing up the key verified the device that the key is from."
		},
		{
		  "name": "session_data",
		  "type": "object",
		  "desc": "Required: Algorithm-dependent data. See the documentation for the backup algorithms in Server-side key backups for more information on the expected format of the data."
		}
	  ],
	  "RoomKeysUpdateResponse": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "Required: The number of keys stored in the backup"
		},
		{
		  "name": "etag",
		  "type": "string",
		  "desc": "Required: The new etag value representing stored keys in the backup. See GET /room_keys/version/{version} for more details."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys/{roomId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room that the specified key is for."
		}
	  ],
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup from which to delete the key."
		}
	  ],
	  "RoomKeysUpdateResponse": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "Required: The number of keys stored in the backup"
		},
		{
		  "name": "etag",
		  "type": "string",
		  "desc": "Required: The new etag value representing stored keys in the backup. See GET /room_keys/version/{version} for more details."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys/{roomId}/{sessionId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room that the requested key is for."
		},
		{
		  "name": "sessionId",
		  "type": "string",
		  "desc": "Required: The ID of the megolm session whose key is requested."
		}
	  ],
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup from which to retrieve the key."
		}
	  ],
	  "KeyBackupData": [
		{
		  "name": "first_message_index",
		  "type": "integer",
		  "desc": "Required: The index of the first message in the session that the key can decrypt."
		},
		{
		  "name": "forwarded_count",
		  "type": "integer",
		  "desc": "Required: The number of times this key has been forwarded via key-sharing between devices."
		},
		{
		  "name": "is_verified",
		  "type": "boolean",
		  "desc": "Required: Whether the device backing up the key verified the device that the key is from."
		},
		{
		  "name": "session_data",
		  "type": "object",
		  "desc": "Required: Algorithm-dependent data. See the documentation for the backup algorithms in Server-side key backups for more information on the expected format of the data."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys/{roomId}/{sessionId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room that the key is for."
		},
		{
		  "name": "sessionId",
		  "type": "string",
		  "desc": "Required: The ID of the megolm session that the key is for."
		}
	  ],
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup in which to store the key. Must be the current backup."
		}
	  ],
	  "KeyBackupData": [
		{
		  "name": "first_message_index",
		  "type": "integer",
		  "desc": "Required: The index of the first message in the session that the key can decrypt."
		},
		{
		  "name": "forwarded_count",
		  "type": "integer",
		  "desc": "Required: The number of times this key has been forwarded via key-sharing between devices."
		},
		{
		  "name": "is_verified",
		  "type": "boolean",
		  "desc": "Required: Whether the device backing up the key verified the device that the key is from."
		},
		{
		  "name": "session_data",
		  "type": "object",
		  "desc": "Required: Algorithm-dependent data. See the documentation for the backup algorithms in Server-side key backups for more information on the expected format of the data."
		}
	  ],
	  "RoomKeysUpdateResponse": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "Required: The number of keys stored in the backup"
		},
		{
		  "name": "etag",
		  "type": "string",
		  "desc": "Required: The new etag value representing stored keys in the backup. See GET /room_keys/version/{version} for more details."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/keys/{roomId}/{sessionId}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room that the specified key is for."
		},
		{
		  "name": "sessionId",
		  "type": "string",
		  "desc": "Required: The ID of the megolm session whose key is to be deleted."
		}
	  ],
	  "query parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup from which to delete the key"
		}
	  ],
	  "RoomKeysUpdateResponse": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "Required: The number of keys stored in the backup"
		},
		{
		  "name": "etag",
		  "type": "string",
		  "desc": "Required: The new etag value representing stored keys in the backup. See GET /room_keys/version/{version} for more details."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/version",
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/version",
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/version/{version}",
	  "path parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup version to get, as returned in the version parameter of the response in POST /_matrix/client/v3/room_keys/version or this endpoint."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/version/{version}",
	  "path parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup version to update, as returned in the version parameter in the response of POST /_matrix/client/v3/room_keys/version or GET /_matrix/client/v3/room_keys/version/{version}."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/room_keys/version/{version}",
	  "path parameters": [
		{
		  "name": "version",
		  "type": "string",
		  "desc": "Required: The backup version to delete, as returned in the version parameter in the response of POST /_matrix/client/v3/room_keys/version or GET /_matrix/client/v3/room_keys/version/{version}."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/keys/changes",
	  "query parameters": [
		{
		  "name": "from",
		  "type": "string",
		  "desc": "Required: The desired start point of the list. Should be the next_batch field from a response to an earlier call to /sync. Users who have not uploaded new device identity keys since this point, nor deleted existing devices with identity keys since then, will be excluded from the results."
		},
		{
		  "name": "to",
		  "type": "string",
		  "desc": "Required: The desired end point of the list. Should be the next_batch field from a recent call to /sync - typically the most recent such call. This may be used by the server as a hint to check its caches are up to date."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/keys/claim"
	},
	{
	  "endpoint": "/_matrix/client/v3/keys/query",
	  "DeviceInformation": [
		{
		  "name": "algorithms",
		  "type": "[string]",
		  "desc": "Required: The encryption algorithms supported by this device."
		},
		{
		  "name": "device_id",
		  "type": "string",
		  "desc": "Required: The ID of the device these keys belong to. Must match the device ID used when logging in."
		},
		{
		  "name": "keys",
		  "type": "{string: string}",
		  "desc": "Required: Public identity keys. The names of the properties should be in the format <algorithm>:<device_id>. The keys themselves should be encoded as specified by the key algorithm."
		},
		{
		  "name": "signatures",
		  "type": "Signatures",
		  "desc": "Required:\n\nSignatures for the device key object. A map from user ID, to a map from <algorithm>:<device_id> to the signature.\n\nThe signature is calculated using the process described at Signing JSON."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedDeviceInfo",
		  "desc": "Additional data added to the device key information by intermediate servers, and not covered by the signatures."
		},
		{
		  "name": "user_id",
		  "type": "string",
		  "desc": "Required: The ID of the user the device belongs to. Must match the user ID used when logging in."
		}
	  ],
	  "UnsignedDeviceInfo": [
		{
		  "name": "device_display_name",
		  "type": "string",
		  "desc": "The display name which the user set on the device."
		}
	  ],
	  "CrossSigningKey": [
		{
		  "name": "keys",
		  "type": "{string: string}",
		  "desc": "Required: The public key. The object must have exactly one property, whose name is in the form <algorithm>:<unpadded_base64_public_key>, and whose value is the unpadded base64 public key."
		},
		{
		  "name": "signatures",
		  "type": "Signatures",
		  "desc": "Signatures of the key, calculated using the process described at Signing JSON. Optional for the master key. Other keys must be signed by the user's master key."
		},
		{
		  "name": "usage",
		  "type": "[string]",
		  "desc": "Required: What the key is used for."
		},
		{
		  "name": "user_id",
		  "type": "string",
		  "desc": "Required: The ID of the user the key belongs to."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/keys/upload",
	  "DeviceKeys": [
		{
		  "name": "algorithms",
		  "type": "[string]",
		  "desc": "Required: The encryption algorithms supported by this device."
		},
		{
		  "name": "device_id",
		  "type": "string",
		  "desc": "Required: The ID of the device these keys belong to. Must match the device ID used when logging in."
		},
		{
		  "name": "keys",
		  "type": "{string: string}",
		  "desc": "Required: Public identity keys. The names of the properties should be in the format <algorithm>:<device_id>. The keys themselves should be encoded as specified by the key algorithm."
		},
		{
		  "name": "signatures",
		  "type": "Signatures",
		  "desc": "Required:\n\nSignatures for the device key object. A map from user ID, to a map from <algorithm>:<device_id> to the signature.\n\nThe signature is calculated using the process described at Signing JSON."
		},
		{
		  "name": "user_id",
		  "type": "string",
		  "desc": "Required: The ID of the user the device belongs to. Must match the user ID used when logging in."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/",
	  "Ruleset": [
		{
		  "name": "content",
		  "type": "[PushRule]",
		  "desc": ""
		},
		{
		  "name": "override",
		  "type": "[PushRule]",
		  "desc": ""
		},
		{
		  "name": "room",
		  "type": "[PushRule]",
		  "desc": ""
		},
		{
		  "name": "sender",
		  "type": "[PushRule]",
		  "desc": ""
		},
		{
		  "name": "underride",
		  "type": "[PushRule]",
		  "desc": ""
		}
	  ],
	  "PushRule": [
		{
		  "name": "actions",
		  "type": "[string|object]",
		  "desc": "Required: The actions to perform when this rule is matched."
		},
		{
		  "name": "conditions",
		  "type": "[PushCondition]",
		  "desc": "The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to underride and override rules."
		},
		{
		  "name": "default",
		  "type": "boolean",
		  "desc": "Required: Whether this is a default rule, or has been set explicitly."
		},
		{
		  "name": "enabled",
		  "type": "boolean",
		  "desc": "Required: Whether the push rule is enabled or not."
		},
		{
		  "name": "pattern",
		  "type": "string",
		  "desc": "The glob-style pattern to match against. Only applicable to content rules."
		},
		{
		  "name": "rule_id",
		  "type": "string",
		  "desc": "Required: The ID of this rule."
		}
	  ],
	  "PushCondition": [
		{
		  "name": "is",
		  "type": "string",
		  "desc": "Required for room_member_count conditions. A decimal integer optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches rooms where the member count is strictly less than the given number and so forth. If no prefix is present, this parameter defaults to ==."
		},
		{
		  "name": "key",
		  "type": "string",
		  "desc": "Required for event_match, event_property_is and event_property_contains conditions. The dot-separated field of the event to match.\n\nRequired for sender_notification_permission conditions. The field in the power level event the user needs a minimum power level for. Fields must be specified under the notifications property in the power level event’s content."
		},
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of condition to apply. See conditions for more information on the allowed kinds and how they work."
		},
		{
		  "name": "pattern",
		  "type": "string",
		  "desc": "Required for event_match conditions. The glob-style pattern to match against."
		},
		{
		  "name": "value",
		  "type": "[string integer boolean null]",
		  "desc": "Required for event_property_is and event_property_contains conditions. A non-compound canonical JSON value to match against."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: global to specify global rules."
		}
	  ],
	  "PushRule": [
		{
		  "name": "actions",
		  "type": "[string|object]",
		  "desc": "Required: The actions to perform when this rule is matched."
		},
		{
		  "name": "conditions",
		  "type": "[PushCondition]",
		  "desc": "The conditions that must hold true for an event in order for a rule to be applied to an event. A rule with no conditions always matches. Only applicable to underride and override rules."
		},
		{
		  "name": "default",
		  "type": "boolean",
		  "desc": "Required: Whether this is a default rule, or has been set explicitly."
		},
		{
		  "name": "enabled",
		  "type": "boolean",
		  "desc": "Required: Whether the push rule is enabled or not."
		},
		{
		  "name": "pattern",
		  "type": "string",
		  "desc": "The glob-style pattern to match against. Only applicable to content rules."
		},
		{
		  "name": "rule_id",
		  "type": "string",
		  "desc": "Required: The ID of this rule."
		}
	  ],
	  "PushCondition": [
		{
		  "name": "is",
		  "type": "string",
		  "desc": "Required for room_member_count conditions. A decimal integer optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches rooms where the member count is strictly less than the given number and so forth. If no prefix is present, this parameter defaults to ==."
		},
		{
		  "name": "key",
		  "type": "string",
		  "desc": "Required for event_match, event_property_is and event_property_contains conditions. The dot-separated field of the event to match.\n\nRequired for sender_notification_permission conditions. The field in the power level event the user needs a minimum power level for. Fields must be specified under the notifications property in the power level event’s content."
		},
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of condition to apply. See conditions for more information on the allowed kinds and how they work."
		},
		{
		  "name": "pattern",
		  "type": "string",
		  "desc": "Required for event_match conditions. The glob-style pattern to match against."
		},
		{
		  "name": "value",
		  "type": "[string integer boolean null]",
		  "desc": "Required for event_property_is and event_property_contains conditions. A non-compound canonical JSON value to match against."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule. If the string starts with a dot (\".\"), the request MUST be rejected as this is reserved for server-default rules. Slashes (\"/\") and backslashes (\"\\\") are also not allowed."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: global to specify global rules."
		}
	  ],
	  "query parameters": [
		{
		  "name": "after",
		  "type": "string",
		  "desc": "This makes the new rule the next-less important rule relative to the given user defined rule. It is not possible to add a rule relative to a predefined server rule."
		},
		{
		  "name": "before",
		  "type": "string",
		  "desc": "Use ‘before’ with a rule_id as its value to make the new rule the next-most important rule with respect to the given user defined rule. It is not possible to add a rule relative to a predefined server rule."
		}
	  ],
	  "PushCondition": [
		{
		  "name": "is",
		  "type": "string",
		  "desc": "Required for room_member_count conditions. A decimal integer optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches rooms where the member count is strictly less than the given number and so forth. If no prefix is present, this parameter defaults to ==."
		},
		{
		  "name": "key",
		  "type": "string",
		  "desc": "Required for event_match, event_property_is and event_property_contains conditions. The dot-separated field of the event to match.\n\nRequired for sender_notification_permission conditions. The field in the power level event the user needs a minimum power level for. Fields must be specified under the notifications property in the power level event’s content."
		},
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of condition to apply. See conditions for more information on the allowed kinds and how they work."
		},
		{
		  "name": "pattern",
		  "type": "string",
		  "desc": "Required for event_match conditions. The glob-style pattern to match against."
		},
		{
		  "name": "value",
		  "type": "[string integer boolean null]",
		  "desc": "Required for event_property_is and event_property_contains conditions. A non-compound canonical JSON value to match against."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: global to specify global rules."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/actions",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: Either global or device/<profile_tag> to specify global rules or device rules for the given profile_tag."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/actions",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: global to specify global rules."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/enabled",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: Either global or device/<profile_tag> to specify global rules or device rules for the given profile_tag."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/enabled",
	  "path parameters": [
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of rule\n\nOne of: [override, underride, sender, room, content]."
		},
		{
		  "name": "ruleId",
		  "type": "string",
		  "desc": "Required: The identifier for the rule."
		},
		{
		  "name": "scope",
		  "type": "string",
		  "desc": "Required: global to specify global rules."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushers",
	  "Pusher": [
		{
		  "name": "app_display_name",
		  "type": "string",
		  "desc": "Required: A string that will allow the user to identify what application owns this pusher."
		},
		{
		  "name": "app_id",
		  "type": "string",
		  "desc": "Required: This is a reverse-DNS style identifier for the application. Max length, 64 chars."
		},
		{
		  "name": "data",
		  "type": "PusherData",
		  "desc": "Required: A dictionary of information for the pusher implementation itself."
		},
		{
		  "name": "device_display_name",
		  "type": "string",
		  "desc": "Required: A string that will allow the user to identify what device owns this pusher."
		},
		{
		  "name": "kind",
		  "type": "string",
		  "desc": "Required: The kind of pusher. \"http\" is a pusher that sends HTTP pokes."
		},
		{
		  "name": "lang",
		  "type": "string",
		  "desc": "Required: The preferred language for receiving notifications (e.g. ’en' or ’en-US')"
		},
		{
		  "name": "profile_tag",
		  "type": "string",
		  "desc": "This string determines which set of device specific rules this pusher executes."
		},
		{
		  "name": "pushkey",
		  "type": "string",
		  "desc": "Required: This is a unique identifier for this pusher. See /set for more detail. Max length, 512 bytes."
		}
	  ],
	  "PusherData": [
		{
		  "name": "format",
		  "type": "string",
		  "desc": "The format to use when sending notifications to the Push Gateway."
		},
		{
		  "name": "url",
		  "type": "string",
		  "desc": "Required if kind is http. The URL to use to send notifications to."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/pushers/set",
	  "PusherData": [
		{
		  "name": "format",
		  "type": "string",
		  "desc": "The format to send notifications in to Push Gateways if the kind is http. The details about what fields the homeserver should send to the push gateway are defined in the Push Gateway Specification. Currently the only format available is ’event_id_only'."
		},
		{
		  "name": "url",
		  "type": "string",
		  "desc": "Required if kind is http. The URL to use to send notifications to. MUST be an HTTPS URL with a path of /_matrix/push/v1/notify."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/notifications",
	  "query parameters": [
		{
		  "name": "from",
		  "type": "string",
		  "desc": "Pagination token to continue from. This should be the next_token returned from an earlier call to this endpoint."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "Limit on the number of events to return in this request."
		},
		{
		  "name": "only",
		  "type": "string",
		  "desc": "Allows basic filtering of events returned. Supply highlight to return only events where the notification had the highlight tweak set."
		}
	  ],
	  "Notification": [
		{
		  "name": "actions",
		  "type": "[object|string]",
		  "desc": "Required: The action(s) to perform when the conditions for this rule are met. See Push Rules: API."
		},
		{
		  "name": "event",
		  "type": "Event",
		  "desc": "Required: The Event object for the event that triggered the notification."
		},
		{
		  "name": "profile_tag",
		  "type": "string",
		  "desc": "The profile tag of the rule that matched this event."
		},
		{
		  "name": "read",
		  "type": "boolean",
		  "desc": "Required: Indicates whether the user has sent a read receipt indicating that they have read this message."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room in which the event was posted."
		},
		{
		  "name": "ts",
		  "type": "integer",
		  "desc": "Required: The unix timestamp at which the event notification was sent, in milliseconds."
		}
	  ],
	  "Event": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEventWithoutRoomID",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/invite",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room identifier (not alias) to which to invite the user."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/search",
	  "query parameters": [
		{
		  "name": "next_batch",
		  "type": "string",
		  "desc": "The point to return events from. If given, this should be a next_batch result from a previous call to this endpoint."
		}
	  ],
	  "Categories": [
		{
		  "name": "room_events",
		  "type": "Room Events Criteria",
		  "desc": "Mapping of category name to search criteria."
		}
	  ],
	  "Room Events Criteria": [
		{
		  "name": "event_context",
		  "type": "Include Event Context",
		  "desc": "Configures whether any context for the events returned are included in the response."
		},
		{
		  "name": "filter",
		  "type": "Filter",
		  "desc": "This takes a filter."
		},
		{
		  "name": "groupings",
		  "type": "Groupings",
		  "desc": "Requests that the server partitions the result set based on the provided list of keys."
		},
		{
		  "name": "include_state",
		  "type": "boolean",
		  "desc": "Requests the server return the current state for each room returned."
		},
		{
		  "name": "keys",
		  "type": "[string]",
		  "desc": "The keys to search. Defaults to all."
		},
		{
		  "name": "order_by",
		  "type": "string",
		  "desc": "The order in which to search for results. By default, this is \"rank\".\n\nOne of: [recent, rank]."
		},
		{
		  "name": "search_term",
		  "type": "string",
		  "desc": "Required: The string to search events for"
		}
	  ],
	  "Include Event Context": [
		{
		  "name": "after_limit",
		  "type": "integer",
		  "desc": "How many events after the result are returned. By default, this is 5."
		},
		{
		  "name": "before_limit",
		  "type": "integer",
		  "desc": "How many events before the result are returned. By default, this is 5."
		},
		{
		  "name": "include_profile",
		  "type": "boolean",
		  "desc": "Requests that the server returns the historic profile information for the users that sent the events that were returned. By default, this is false."
		}
	  ],
	  "Filter": [
		{
		  "name": "contains_url",
		  "type": "boolean",
		  "desc": "If true, includes only events with a url key in their content. If false, excludes those events. If omitted, url key is not considered for filtering."
		},
		{
		  "name": "include_redundant_members",
		  "type": "boolean",
		  "desc": "If true, sends all membership events for all events, even if they have already been sent to the client. Does not apply unless lazy_load_members is true. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "lazy_load_members",
		  "type": "boolean",
		  "desc": "If true, enables lazy-loading of membership events. See Lazy-loading room members for more information. Defaults to false."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of events to return, must be an integer greater than 0.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "not_rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the 'rooms' filter."
		},
		{
		  "name": "not_senders",
		  "type": "[string]",
		  "desc": "A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the 'senders' filter."
		},
		{
		  "name": "not_types",
		  "type": "[string]",
		  "desc": "A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the 'types' filter. A ‘*’ can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "rooms",
		  "type": "[string]",
		  "desc": "A list of room IDs to include. If this list is absent then all rooms are included."
		},
		{
		  "name": "senders",
		  "type": "[string]",
		  "desc": "A list of senders IDs to include. If this list is absent then all senders are included."
		},
		{
		  "name": "types",
		  "type": "[string]",
		  "desc": "A list of event types to include. If this list is absent then all event types are included. A '*' can be used as a wildcard to match any sequence of characters."
		},
		{
		  "name": "unread_thread_notifications",
		  "type": "boolean",
		  "desc": "If true, enables per-thread notification counts. Only applies to the /sync endpoint. Defaults to false.\n\nAdded in v1.4"
		}
	  ],
	  "Groupings": [
		{
		  "name": "group_by",
		  "type": "[Group]",
		  "desc": "List of groups to request."
		}
	  ],
	  "Group": [
		{
		  "name": "key",
		  "type": "string",
		  "desc": "Key that defines the group.\n\nOne of: [room_id, sender]."
		}
	  ],
	  "Results": [
		{
		  "name": "search_categories",
		  "type": "Result Categories",
		  "desc": "Required: Describes which categories to search in and their criteria."
		}
	  ],
	  "Result Categories": [
		{
		  "name": "room_events",
		  "type": "Result Room Events",
		  "desc": "Mapping of category name to search criteria."
		}
	  ],
	  "Result Room Events": [
		{
		  "name": "count",
		  "type": "integer",
		  "desc": "An approximate count of the total number of results found."
		},
		{
		  "name": "groups",
		  "type": "Groups",
		  "desc": "Any groups that were requested.\n\nThe outer string key is the group key requested (eg: room_id or sender). The inner string key is the grouped value (eg: a room’s ID or a user’s ID)."
		},
		{
		  "name": "highlights",
		  "type": "[string]",
		  "desc": "List of words which should be highlighted, useful for stemming which may change the query terms."
		},
		{
		  "name": "next_batch",
		  "type": "string",
		  "desc": "Token that can be used to get the next batch of results, by passing as the next_batch parameter to the next call. If this field is absent, there are no more results."
		},
		{
		  "name": "results",
		  "type": "[Result]",
		  "desc": "List of results in the requested order."
		},
		{
		  "name": "state",
		  "type": "Current state",
		  "desc": "The current state for every room in the results. This is included if the request had the include_state key set with a value of true.\n\nThe string key is the room ID for which the State Event array belongs to."
		}
	  ],
	  "Group Value": [
		{
		  "name": "next_batch",
		  "type": "string",
		  "desc": "Token that can be used to get the next batch of results in the group, by passing as the next_batch parameter to the next call. If this field is absent, there are no more results in this group."
		},
		{
		  "name": "order",
		  "type": "integer",
		  "desc": "Key that can be used to order different groups."
		},
		{
		  "name": "results",
		  "type": "[Result Event ID]",
		  "desc": "Which results are in this group."
		}
	  ],
	  "Result": [
		{
		  "name": "context",
		  "type": "Event Context",
		  "desc": "Context for result, if requested."
		},
		{
		  "name": "rank",
		  "type": "number",
		  "desc": "A number that describes how closely this result matches the search. Higher is closer."
		},
		{
		  "name": "result",
		  "type": "Event",
		  "desc": "The event that matched."
		}
	  ],
	  "Event Context": [
		{
		  "name": "end",
		  "type": "string",
		  "desc": "Pagination token for the end of the chunk"
		},
		{
		  "name": "events_after",
		  "type": "[Event]",
		  "desc": "Events just after the result."
		},
		{
		  "name": "events_before",
		  "type": "[Event]",
		  "desc": "Events just before the result."
		},
		{
		  "name": "profile_info",
		  "type": "Profile Information",
		  "desc": "The historic profile information of the users that sent the events returned.\n\nThe string key is the user ID for which the profile belongs to."
		},
		{
		  "name": "start",
		  "type": "string",
		  "desc": "Pagination token for the start of the chunk"
		}
	  ],
	  "Event": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "User Profile": [
		{
		  "name": "avatar_url",
		  "type": "string",
		  "desc": ""
		},
		{
		  "name": "displayname",
		  "type": "string",
		  "desc": ""
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/events ",
	  "query parameters": [
		{
		  "name": "from",
		  "type": "string",
		  "desc": "The token to stream from. This token is either from a previous request to this API or from the initial sync API."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "The room ID for which events should be returned."
		},
		{
		  "name": "timeout",
		  "type": "integer",
		  "desc": "The maximum time in milliseconds to wait for an event."
		}
	  ],
	  "Event": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/rooms/{roomId}/tags",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to get tags for."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The id of the user to get tags for. The access token must be authorized to make requests for this user ID."
		}
	  ],
	  "Tag": [
		{
		  "name": "order",
		  "type": "number",
		  "desc": "A number in a range [0,1] describing a relative position of the room under the given tag."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/rooms/{roomId}/tags/{tag}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to add a tag to."
		},
		{
		  "name": "tag",
		  "type": "string",
		  "desc": "Required: The tag to add."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The id of the user to add a tag for. The access token must be authorized to make requests for this user ID."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/rooms/{roomId}/tags/{tag}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to remove a tag from."
		},
		{
		  "name": "tag",
		  "type": "string",
		  "desc": "Required: The tag to remove."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The id of the user to remove a tag for. The access token must be authorized to make requests for this user ID."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/account_data/{type}",
	  "path parameters": [
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The event type of the account data to get. Custom types should be namespaced to avoid clashes."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The ID of the user to get account data for. The access token must be authorized to make requests for this user ID."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/account_data/{type}",
	  "path parameters": [
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The event type of the account data to set. Custom types should be namespaced to avoid clashes."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The ID of the user to set account data for. The access token must be authorized to make requests for this user ID."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/rooms/{roomId}/account_data/{type}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to get account data for."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The event type of the account data to get. Custom types should be namespaced to avoid clashes."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The ID of the user to get account data for. The access token must be authorized to make requests for this user ID."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/rooms/{roomId}/account_data/{type}",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to set account data on."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The event type of the account data to set. Custom types should be namespaced to avoid clashes."
		},
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The ID of the user to set account data for. The access token must be authorized to make requests for this user ID."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/admin/whois/{userId}",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user to look up."
		}
	  ],
	  "DeviceInfo": [
		{
		  "name": "sessions",
		  "type": "[SessionInfo]",
		  "desc": "A user’s sessions (i.e. what they did with an access token from one login)."
		}
	  ],
	  "SessionInfo": [
		{
		  "name": "connections",
		  "type": "[ConnectionInfo]",
		  "desc": "Information particular connections in the session."
		}
	  ],
	  "ConnectionInfo": [
		{
		  "name": "ip",
		  "type": "string",
		  "desc": "Most recently seen IP address of the session."
		},
		{
		  "name": "last_seen",
		  "type": "integer",
		  "desc": "Unix timestamp that the session was last active."
		},
		{
		  "name": "user_agent",
		  "type": "string",
		  "desc": "User agent string last seen in the session."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/context/{eventId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The event to get context around."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room to get events from."
		}
	  ],
	  "query parameters": [
		{
		  "name": "filter",
		  "type": "string",
		  "desc": "A JSON RoomEventFilter to filter the returned events with. The filter is only applied to events_before, events_after, and state. It is not applied to the event itself. The filter may be applied before or/and after the limit parameter - whichever the homeserver prefers.\n\nSee Filtering for more information."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "The maximum number of context events to return. The limit applies to the sum of the events_before and events_after arrays. The requested event ID is always returned in event even if limit is 0. Defaults to 10."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/login/sso/redirect",
	  "query parameters": [
		{
		  "name": "redirectUrl",
		  "type": "string",
		  "desc": "Required: URI to which the user will be redirected after the homeserver has authenticated the user with SSO."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/login/sso/redirect/{idpId}",
	  "path parameters": [
		{
		  "name": "idpId",
		  "type": "string",
		  "desc": "Required: The id of the IdP from the m.login.sso identity_providers array denoting the user’s selection."
		}
	  ],
	  "query parameters": [
		{
		  "name": "redirectUrl",
		  "type": "string",
		  "desc": "Required: URI to which the user will be redirected after the homeserver has authenticated the user with SSO."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/report/{eventId}",
	  "path parameters": [
		{
		  "name": "eventId",
		  "type": "string",
		  "desc": "Required: The event to report."
		},
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room in which the event being reported is located."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/thirdparty/location",
	  "query parameters": [
		{
		  "name": "alias",
		  "type": "string",
		  "desc": "Required: The Matrix room alias to look up."
		}
	  ],
	  "Location": [
		{
		  "name": "alias",
		  "type": "string",
		  "desc": "Required: An alias for a matrix room."
		},
		{
		  "name": "fields",
		  "type": "object",
		  "desc": "Required: Information used to identify this third-party location."
		},
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The protocol ID that the third-party location is a part of."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/thirdparty/location/{protocol}",
	  "path parameters": [
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The protocol used to communicate to the third-party network."
		}
	  ],
	  "query parameters": [
		{
		  "name": "searchFields",
		  "type": "string",
		  "desc": "One or more custom fields to help identify the third-party location."
		}
	  ],
	  "Location": [
		{
		  "name": "alias",
		  "type": "string",
		  "desc": "Required: An alias for a matrix room."
		},
		{
		  "name": "fields",
		  "type": "object",
		  "desc": "Required: Information used to identify this third-party location."
		},
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The protocol ID that the third-party location is a part of."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/thirdparty/protocol/{protocol}",
	  "path parameters": [
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The name of the protocol."
		}
	  ],
	  "Protocol": [
		{
		  "name": "field_types",
		  "type": "{string: Field Type}",
		  "desc": "Required:\n\nThe type definitions for the fields defined in the user_fields and location_fields. Each entry in those arrays MUST have an entry here. The string key for this object is field name itself.\n\nMay be an empty object if no fields are defined."
		},
		{
		  "name": "icon",
		  "type": "string",
		  "desc": "Required: A content URI representing an icon for the third-party protocol."
		},
		{
		  "name": "instances",
		  "type": "[Protocol Instance]",
		  "desc": "Required: A list of objects representing independent instances of configuration. For example, multiple networks on IRC if multiple are provided by the same application service."
		},
		{
		  "name": "location_fields",
		  "type": "[string]",
		  "desc": "Required: Fields which may be used to identify a third-party location. These should be ordered to suggest the way that entities may be grouped, where higher groupings are ordered first. For example, the name of a network should be searched before the name of a channel."
		},
		{
		  "name": "user_fields",
		  "type": "[string]",
		  "desc": "Required: Fields which may be used to identify a third-party user. These should be ordered to suggest the way that entities may be grouped, where higher groupings are ordered first. For example, the name of a network should be searched before the nickname of a user."
		}
	  ],
	  "Field Type": [
		{
		  "name": "placeholder",
		  "type": "string",
		  "desc": "Required: An placeholder serving as a valid example of the field value."
		},
		{
		  "name": "regexp",
		  "type": "string",
		  "desc": "Required: A regular expression for validation of a field’s value. This may be relatively coarse to verify the value as the application service providing this protocol may apply additional validation or filtering."
		}
	  ],
	  "Protocol Instance": [
		{
		  "name": "desc",
		  "type": "string",
		  "desc": "Required: A human-readable description for the protocol, such as the name."
		},
		{
		  "name": "fields",
		  "type": "object",
		  "desc": "Required: Preset values for fields the client may use to search by."
		},
		{
		  "name": "icon",
		  "type": "string",
		  "desc": "An optional content URI representing the protocol. Overrides the one provided at the higher level Protocol object."
		},
		{
		  "name": "network_id",
		  "type": "string",
		  "desc": "Required: A unique identifier across all instances."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/thirdparty/protocols",
	  "Protocol": [
		{
		  "name": "field_types",
		  "type": "{string: Field Type}",
		  "desc": "Required:\n\nThe type definitions for the fields defined in the user_fields and location_fields. Each entry in those arrays MUST have an entry here. The string key for this object is field name itself.\n\nMay be an empty object if no fields are defined."
		},
		{
		  "name": "icon",
		  "type": "string",
		  "desc": "Required: A content URI representing an icon for the third-party protocol."
		},
		{
		  "name": "instances",
		  "type": "[Protocol Instance]",
		  "desc": "Required: A list of objects representing independent instances of configuration. For example, multiple networks on IRC if multiple are provided by the same application service."
		},
		{
		  "name": "location_fields",
		  "type": "[string]",
		  "desc": "Required: Fields which may be used to identify a third-party location. These should be ordered to suggest the way that entities may be grouped, where higher groupings are ordered first. For example, the name of a network should be searched before the name of a channel."
		},
		{
		  "name": "user_fields",
		  "type": "[string]",
		  "desc": "Required: Fields which may be used to identify a third-party user. These should be ordered to suggest the way that entities may be grouped, where higher groupings are ordered first. For example, the name of a network should be searched before the nickname of a user."
		}
	  ],
	  "Field Type": [
		{
		  "name": "placeholder",
		  "type": "string",
		  "desc": "Required: An placeholder serving as a valid example of the field value."
		},
		{
		  "name": "regexp",
		  "type": "string",
		  "desc": "Required: A regular expression for validation of a field’s value. This may be relatively coarse to verify the value as the application service providing this protocol may apply additional validation or filtering."
		}
	  ],
	  "Protocol Instance": [
		{
		  "name": "desc",
		  "type": "string",
		  "desc": "Required: A human-readable description for the protocol, such as the name."
		},
		{
		  "name": "fields",
		  "type": "object",
		  "desc": "Required: Preset values for fields the client may use to search by."
		},
		{
		  "name": "icon",
		  "type": "string",
		  "desc": "An optional content URI representing the protocol. Overrides the one provided at the higher level Protocol object."
		},
		{
		  "name": "network_id",
		  "type": "string",
		  "desc": "Required: A unique identifier across all instances."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/thirdparty/user",
	  "query parameters": [
		{
		  "name": "userid",
		  "type": "string",
		  "desc": "Required: The Matrix User ID to look up."
		}
	  ],
	  "User": [
		{
		  "name": "fields",
		  "type": "object",
		  "desc": "Required: Information used to identify this third-party location."
		},
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The protocol ID that the third-party location is a part of."
		},
		{
		  "name": "userid",
		  "type": "string",
		  "desc": "Required: A Matrix User ID represting a third-party user."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/thirdparty/user/{protocol}",
	  "path parameters": [
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The name of the protocol."
		}
	  ],
	  "query parameters": [
		{
		  "name": "fields",
		  "type": "{string: string}",
		  "desc": "One or more custom fields that are passed to the AS to help identify the user."
		}
	  ],
	  "User": [
		{
		  "name": "fields",
		  "type": "object",
		  "desc": "Required: Information used to identify this third-party location."
		},
		{
		  "name": "protocol",
		  "type": "string",
		  "desc": "Required: The protocol ID that the third-party location is a part of."
		},
		{
		  "name": "userid",
		  "type": "string",
		  "desc": "Required: A Matrix User ID represting a third-party user."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/user/{userId}/openid/request_token",
	  "path parameters": [
		{
		  "name": "userId",
		  "type": "string",
		  "desc": "Required: The user to request an OpenID token for. Should be the user who is authenticated for the request."
		}
	  ],
	  "OpenIdCredentials": [
		{
		  "name": "access_token",
		  "type": "string",
		  "desc": "Required: An access token the consumer may use to verify the identity of the person who generated the token. This is given to the federation API GET /openid/userinfo to verify the user’s identity."
		},
		{
		  "name": "expires_in",
		  "type": "integer",
		  "desc": "Required: The number of seconds before this token expires and a new one must be generated."
		},
		{
		  "name": "matrix_server_name",
		  "type": "string",
		  "desc": "Required: The homeserver domain the consumer should use when attempting to verify the user’s identity."
		},
		{
		  "name": "token_type",
		  "type": "string",
		  "desc": "Required: The string Bearer."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v3/rooms/{roomId}/upgrade",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The ID of the room to upgrade."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/rooms/{roomId}/hierarchy",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room ID of the space to get a hierarchy for."
		}
	  ],
	  "query parameters": [
		{
		  "name": "from",
		  "type": "string",
		  "desc": "A pagination token from a previous result. If specified, max_depth and suggested_only cannot be changed from the first request."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "Optional limit for the maximum number of rooms to include per response. Must be an integer greater than zero.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "max_depth",
		  "type": "integer",
		  "desc": "Optional limit for how far to go into the space. Must be a non-negative integer.\n\nWhen reached, no further child rooms will be returned.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		},
		{
		  "name": "suggested_only",
		  "type": "boolean",
		  "desc": "Optional (default false) flag to indicate whether or not the server should only consider suggested rooms. Suggested rooms are annotated in their m.space.child event contents."
		}
	  ],
	  "SpaceHierarchyRoomsChunk": [
		{
		  "name": "avatar_url",
		  "type": "string",
		  "desc": "The URL for the room’s avatar, if one is set."
		},
		{
		  "name": "canonical_alias",
		  "type": "string",
		  "desc": "The canonical alias of the room, if any."
		},
		{
		  "name": "children_state",
		  "type": "[StrippedChildStateEvent]",
		  "desc": "Required:\n\nThe m.space.child events of the space-room, represented as Stripped State Events with an added origin_server_ts key.\n\nIf the room is not a space-room, this should be empty."
		},
		{
		  "name": "guest_can_join",
		  "type": "boolean",
		  "desc": "Required: Whether guest users may join the room and participate in it. If they can, they will be subject to ordinary power level rules like any other user."
		},
		{
		  "name": "join_rule",
		  "type": "string",
		  "desc": "The room’s join rule. When not present, the room is assumed to be public."
		},
		{
		  "name": "name",
		  "type": "string",
		  "desc": "The name of the room, if any."
		},
		{
		  "name": "num_joined_members",
		  "type": "integer",
		  "desc": "Required: The number of members joined to the room."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room."
		},
		{
		  "name": "room_type",
		  "type": "string",
		  "desc": "The type of room (from m.room.create), if any.\n\nAdded in v1.4"
		},
		{
		  "name": "topic",
		  "type": "string",
		  "desc": "The topic of the room, if any."
		},
		{
		  "name": "world_readable",
		  "type": "boolean",
		  "desc": "Required: Whether the room may be viewed by guest users without joining."
		}
	  ],
	  "StrippedChildStateEvent": [
		{
		  "name": "content",
		  "type": "EventContent",
		  "desc": "Required: The content for the event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: The origin_server_ts for the event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: The sender for the event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Required: The state_key for the event."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type for the event."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	},
	{
	  "endpoint": "/_matrix/client/v1/rooms/{roomId}/threads",
	  "path parameters": [
		{
		  "name": "roomId",
		  "type": "string",
		  "desc": "Required: The room ID where the thread roots are located."
		}
	  ],
	  "query parameters": [
		{
		  "name": "from",
		  "type": "string",
		  "desc": "A pagination token from a previous result. When not provided, the server starts paginating from the most recent event visible to the user (as per history visibility rules; topologically)."
		},
		{
		  "name": "include",
		  "type": "string",
		  "desc": "Optional (default all) flag to denote which thread roots are of interest to the caller. When all, all thread roots found in the room are returned. When participated, only thread roots for threads the user has participated in will be returned.\n\nOne of: [all, participated]."
		},
		{
		  "name": "limit",
		  "type": "integer",
		  "desc": "Optional limit for the maximum number of thread roots to include per response. Must be an integer greater than zero.\n\nServers should apply a default value, and impose a maximum value to avoid resource exhaustion."
		}
	  ],
	  "ClientEvent": [
		{
		  "name": "content",
		  "type": "object",
		  "desc": "Required: The body of this event, as created by the client which sent it."
		},
		{
		  "name": "event_id",
		  "type": "string",
		  "desc": "Required: The globally unique identifier for this event."
		},
		{
		  "name": "origin_server_ts",
		  "type": "integer",
		  "desc": "Required: Timestamp (in milliseconds since the unix epoch) on originating homeserver when this event was sent."
		},
		{
		  "name": "room_id",
		  "type": "string",
		  "desc": "Required: The ID of the room associated with this event."
		},
		{
		  "name": "sender",
		  "type": "string",
		  "desc": "Required: Contains the fully-qualified ID of the user who sent this event."
		},
		{
		  "name": "state_key",
		  "type": "string",
		  "desc": "Present if, and only if, this event is a state event. The key making this piece of state unique in the room. Note that it is often an empty string.\n\nState keys starting with an @ are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user’s ID as the state key MUST only be set by that user."
		},
		{
		  "name": "type",
		  "type": "string",
		  "desc": "Required: The type of the event."
		},
		{
		  "name": "unsigned",
		  "type": "UnsignedData",
		  "desc": "Contains optional extra information about the event."
		}
	  ],
	  "UnsignedData": [
		{
		  "name": "age",
		  "type": "integer",
		  "desc": "The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is."
		},
		{
		  "name": "prev_content",
		  "type": "EventContent",
		  "desc": "The previous content for this event. This field is generated by the local homeserver, and is only returned if the event is a state event, and the client has permission to see the previous content.\n\nChanged in v1.2: Previously, this field was specified at the top level of returned events rather than in unsigned (with the exception of the GET .../notifications endpoint), though in practice no known server implementations honoured this."
		},
		{
		  "name": "redacted_because",
		  "type": "ClientEvent",
		  "desc": "The event that redacted this event, if any."
		},
		{
		  "name": "transaction_id",
		  "type": "string",
		  "desc": "The client-supplied transaction ID, for example, provided via PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}, if the client being given the event is the same one which sent it."
		}
	  ],
	  "Error": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: An error code."
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		}
	  ],
	  "RateLimitError": [
		{
		  "name": "errcode",
		  "type": "string",
		  "desc": "Required: The M_LIMIT_EXCEEDED error code"
		},
		{
		  "name": "error",
		  "type": "string",
		  "desc": "A human-readable error message."
		},
		{
		  "name": "retry_after_ms",
		  "type": "integer",
		  "desc": "The amount of time in milliseconds the client should wait before trying the request again."
		}
	  ]
	}
  ]
}
